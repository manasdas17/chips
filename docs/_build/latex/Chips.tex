% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{Chips Documentation}
\date{March 27, 2011}
\release{0.1}
\author{Jonathan P Dawson}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\hypertarget{--doc-index}{}


Contents:

\resetcurrentobjects
\hypertarget{--doc-introduction/index}{}

\chapter{Introduction}

The Chips library gives Python the ability to design, simulate and realiseV
digital devices such as FPGAs. Chips provides a simple yet powerful suite of
primitive components, \emph{Streams}, \emph{Processes} and \emph{Sinks} that can be succinclty
combined to form \emph{Chips}. The \emph{Chips} library can automatically convert
\emph{Streams}, \emph{Processes} and \emph{Sinks} into a Hardware Description Language, which
can be synthesised into real hardware.

Python programs cannot themselves be converted into real hardware, but it is
possible to programaticaly generate which construct \emph{Chips}, which can in-turn
be converted into hardware. When combined with the extensive libraries allready
supported by Python, such as NumPy and SciPy, Python and Chips make the ideal
design and verification environment.


\section{A new approach to device design}

Traditionaly, the tool of choice for digital devices is a Hardware Description
Language (HDL), the most common being Verilog and VHDL. These languages provide
a reasonably rich environment for modeling and simulating hardware, but only a
limitied subset of the langauge can be realised in a digital device
(synthesised).

A software designer would typically implement a function in an imperative style
using loops, branches and subprocedures, but hardware models written in an
imperative style cannot be synthesised.

Synthesisable designs require a different approach. Digital device designers
must work at the Register Transfer Level (RTL). The primitive elements of an
RTL design are clocked memory elements (registers) and combinational logic
elements. A typlical synthesis tool would be able to infer boolean logic,
addition, subtraction, multiplexing and bit manipulation from HDL code written
in a very specific style.

An RTL designer has to work at a low level of abstraction. In practical terms
this means that a designer has to do more of the work themselves.
\begin{quote}

1. A designer is reponsible for designing their own interfaces to the
outside world.

2. The designer is responsible for clock to clock timing, manualy
balancing propogation delays between clocked elements to achieve high
performance.

3. A designer has to provide their own mechanism to synchronise and
pass data bwetween concurrent computational elements (by implementing a
bus with control and handshaking signals).

4. A designer has to provide their own mechanism to control the flow of
execution within a computational element (usually by manually coding a
finite state machine).
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
The primitive elements are primitive.

\end{enumerate}
\end{quote}

This is where \emph{Python Chips} comes in. In \emph{Python Chips}, there is no
synthesiseable subset, but a standalone synthesisable language built on top of
Python. \emph{Python Chips} allows designers to work at a higher level of
abstraction. It does a lot more of the work for you.
\begin{quote}

1. \emph{Python Chips} provides a suite of device interfaces including portio,
uart, usb and ethernet.

2. Synthesisable RTL code is generated automatically by the tool. Clocks,
resets, and clock to clock timing are all taken care of behind the scenes.

3. \emph{Python Chips} provides a simple method to synchronise concurrent
elements, and to pass data between them - streams. The tool automatically
generates interconnect busses and handshaking signals behind the scenes.

4. \emph{Python Chips} provides processes with imperative style sequeneces
branches and loop. The tool automatically generates state machines, or highly
optimized soft-core processors behind the scenes.

6. The primitive elements are not so primitive. Common constructs such as
counters, lookup tables, ROMS and RAMS are invoked with a single keyword and a
few parameters. \emph{Python Chips}. also provides a richer set of arithmetic
operators including fully synthesiseable division and multiplication.
\end{quote}


\section{A language within a language}

\emph{Python Chips} is a python library, just an add-on to Python which is no more
or less than a programming language. The \emph{Python Chips} library provides an
Application Programmers Interface (API) to a suite of hardware design
functions.

The \emph{Python Chips} library can also be considered a language in its own right,
The Python language itself provides statements which are executed on your own
computer. The \emph{Python Chips} provides an alternative language, statements which
are executed on the target device.

\resetcurrentobjects
\hypertarget{--doc-language\_reference/index}{}

\chapter{Chips Language Reference manual}


\section{Chip}
\index{Chip (class in chips)}

\hypertarget{chips.Chip}{}\begin{classdesc}{Chip}{*args}
A Chip device containing streams, sinks and processes.

Typically a Chip is used to describe a single device. You need to provide
the Chip object with a list of all the sinks (devie outputs). You don't
need to include any process, variables or streams. By analysing the sinks,
the chip can work out which processes and streams need to be included in
the device.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{switches} \PYG{o}{=} \PYG{n}{InPort}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SWITCHES}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{serial\PYGZus{}in} \PYG{o}{=} \PYG{n}{SerialIn}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{RX}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{leds} \PYG{o}{=} \PYG{n}{OutPort}\PYG{p}{(}\PYG{n}{switches}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{LEDS}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{serial\PYGZus{}out} \PYG{o}{=} \PYG{n}{SerialOut}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{TX}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{serial\PYGZus{}in}\PYG{p}{)}

\PYG{c}{\#We need to tell the *Chip* that *leds* and *serial\PYGZus{}out* are part of}
\PYG{c}{\#the device. The *Chip* can work out for itself that *switches* and}
\PYG{c}{\#*serial\PYGZus{}in* are part of the device.}

\PYG{n}{s} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
    \PYG{n}{leds}\PYG{p}{,}
    \PYG{n}{serial\PYGZus{}out}\PYG{p}{,}
\PYG{p}{)}

\PYG{n}{s}\PYG{o}{.}\PYG{n}{write\PYGZus{}code}\PYG{p}{(}\PYG{n}{plugin}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}


\section{Process}
\index{chips.process (module)}
\hypertarget{module-chips.process}{}
\declaremodule[chips.process]{}{chips.process}
\modulesynopsis{}
\emph{Processes} are used to define the programs that will be executed in the target
\emph{Chip}.  Each \emph{Process} contains a single program made up of instructions. When
a \emph{Chip} is simulated, or run in real hardware, the program within each process
will be run concurrently.


\subsection{Process Inputs}

Any \emph{Stream} may be used as the input to a \emph{Process}. Only one process may read
from any particular stream.  A \emph{Process} may read from a \emph{Stream} using the
\emph{read} method. The \emph{read} method accepts a \emph{Variable} as its argument. A \emph{read}
from a \emph{Stream} will stall execution of the \emph{Process} until data is available.
Similarly, the stream will be stalled, until data is read from it. This
provides a handy way to synchronise processes together, and simplifies the
design of concurrent systems.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#sending process}
\PYG{n}{theoutput} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
    \PYG{c}{\#wait for 1 second}
    \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} 
        \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{c}{\#send some data}
    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+m+mi}{123}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}

\PYG{c}{\#receiving process}
\PYG{n}{target\PYGZus{}variable} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
    \PYG{c}{\#This instruction will stall the process until data is available}
    \PYG{n}{theOutput}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{target\PYGZus{}variable}\PYG{p}{)}\PYG{p}{,}
    \PYG{c}{\#This instruction will not be run for 1 second}
    \PYG{c}{\#..}
\PYG{p}{)}
\end{Verbatim}


\subsection{Process Outputs}

An \emph{Output} is a special \emph{Stream} that can be written to by a \emph{Process}. Only one
\emph{Process} may write to any particular stream. Like any other \emph{Stream}, an
\emph{Output} may be:
\begin{itemize}
\item {} 
Read by a \emph{Process}.

\item {} 
Consumed by a \emph{Sink}.

\item {} 
Modified to form another \emph{Stream}.

\end{itemize}

A \emph{Process} may write to an \emph{Output} stream using the \emph{write} method. The
\emph{write} method accepts an expression as its argument. A \emph{write} to an output
will stall the process until the reciever is ready to recieve data.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#sending process}
\PYG{n}{theoutput} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
    \PYG{c}{\#This instruction will stall the process until data is available}
    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+m+mi}{123}\PYG{p}{)}\PYG{p}{,}
    \PYG{c}{\#This instruction will not be run for 1 second}
    \PYG{c}{\#..}
\PYG{p}{)}

\PYG{c}{\#receiving process}
\PYG{n}{target\PYGZus{}variable} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
    \PYG{c}{\#wait for 1 second}
    \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} 
        \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{c}{\#get some data}
    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{target\PYGZus{}variable}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}


\subsection{Variables}

Data is stored and manipulated within a process using \emph{Variables}. A \emph{Variable}
may only be accessed by one process.  When a \emph{Variable} an initial value must
be supplied. A variable will be reset to its initial value before any process
instructions are executed.  A \emph{Variable} may be assigned a value using the
\emph{set} method. The {\color{red}\bfseries{}*}set method accepts an expression as its argument.

It is important to understand that a \emph{Variable} object created like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}
\end{Verbatim}

is very different from a normal Python variable created like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{12}
\end{Verbatim}

The key is to understand that a \emph{Variable} will exist in the target \emph{Chip}, and
may be assigned and referenced as the \emph{Process} executes. A Python variable can
exist only in the Python environment, and not in a \emph{Chip}. While a Python
variable may be converted into a \emph{Constant} in the target \emph{Chip}, a \emph{Process}
has no way to change its value when it executes.


\subsection{Constants}

Like a \emph{Variable}, a constant must be supplied with an initial valkue when it
is created. Unlike a \emph{Variable}, a the value of a \emph{Constant} can never be
changed.


\subsection{Expressions}

\emph{Variables} and \emph{Constants} are the most basic form of expressions. More
complex expressions can be formed by combining \emph{Constants}, \emph{Variables} and
other expressions using following operators:

\begin{Verbatim}[commandchars=@\[\]]
+, -, *, \/, @%, @&, @textbar[], @textasciicircum[], @textless[]@textless[], @textgreater[]@textgreater[], ==, !=, @textless[], @textless[]=, @textgreater[], @textgreater[]=
\end{Verbatim}

If one of the operands of a binary operator is not an expression, the Chips
library will attempt to convert this operand into an integer. If the conversion
is successfull, a \emph{Constant} object will be created using the integer value.
The \emph{Constant} object will be used in place of the non-expression operand. This
allows constructs such as \code{a = 47+Constant(10)} to be used as a shorthand for
\code{a = Constant(47)+Constant(10)} or \code{count.set(Constant(15)+3*2} to be used
as a shorthand for \code{count.set(Constant(15)+Constant(6)}.  Of course \code{a=1+1}
still yields the integer 2 rather than an expression.

An expression within a process will always inherit the data width in bits of
the \emph{Process} in which it is evaluated. A \emph{Stream} expression such as
\code{Repeater(255) + 1} will automatically yield a 10-bit \emph{Stream} so that the
value 256 can be represented. A similar expression Constant(255)+1 will give an
9-bit result in a 9-bit process yielding the value -1. If the same expression
is evaluated in a 10-bit process, the result will be 256.


\subsection{Operator Precedence}

The operator precedence is inherited from the Python language. The following
table summarizes the operator precedences, from lowest precedence (least
binding) to highest precedence (most binding). Operators in the same row have
the same precedence.

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operator
} & \textbf{
Description
}\\
\hline

==, !=, \textless{}, \textless{}=, \textgreater{}, \textgreater{}=
 & 
Comparisons
\\
{\raggedright{}~}
 & 
Bitwise OR
\\

\textasciicircum{}
 & 
Bitwise XOR
\\

\&
 & 
Bitwise AND
\\

\textless{}\textless{}, \textgreater{}\textgreater{}
 & 
Shifts
\\

+, -
 & 
Addition and subtraction
\\

{\color{red}\bfseries{}*}, //, \%
 & 
multiplication, division and modulo
\\
\hline
\end{tabulary}

\index{Process (class in chips)}

\hypertarget{chips.Process}{}\begin{classdesc}{Process}{bits, *instructions}\end{classdesc}
\index{Variable (class in chips)}

\hypertarget{chips.Variable}{}\begin{classdesc}{Variable}{initial}\end{classdesc}
\index{VariableArray (class in chips)}

\hypertarget{chips.VariableArray}{}\begin{classdesc}{VariableArray}{size}\end{classdesc}


\section{Streams}
\index{chips.streams (module)}
\hypertarget{module-chips.streams}{}
\declaremodule[chips.streams]{}{chips.streams}
\modulesynopsis{}
Streams are a fundamental component of the \emph{Chips} library.
\begin{description}
\item[{A stream is used to represent a flow of data. A stream can act as a:}] \leavevmode\begin{itemize}
\item {} 
An input to a \emph{Chip} such as an \emph{InPort} or a \emph{SerialIn}.

\item {} 
A source of data in its own right such as a \emph{Repeater} or a \emph{Counter}.

\item {} 
A means of performing some operation on a stream of data to form 
another stream such as a \emph{Printer} or a \emph{Lookup}.

\item {} 
A means of transfering data from one process to another, an \emph{Output}.

\end{itemize}

\end{description}


\subsection{Stream Expressions}

A Stream Expression can be formed by combining Streams or Stream Expressions
with the following ooperators:

\begin{Verbatim}[commandchars=@\[\]]
+, -, *, \/, @%, @&, @textbar[], @textasciicircum[], @textless[]@textless[], @textgreater[]@textgreater[], ==, !=, @textless[], @textless[]=, @textgreater[], @textgreater[]=
\end{Verbatim}

Each data item in the resulting Stream Expression will be evaluated by removing
a data item from each of the operand streams, and applying the operator
function to these data items.

Generaly speaking a Stream Expression will have enough bits to contain any
possible result without any arithmetic overflow. The one exception to this is
the left shift operator where the result is always truncated to the size of the
left hand operand. Stream expressions may be explicitly truncated or sign
extended using the \emph{Resizer}.

If one of the operands of a binary operator is not a Stream, Python Streams
will attempt to convert this operand into an integer. If the conversion is
successfull, a \emph{Repeater} stream will be created using the integer value. The
repeater stream will be used in place of the non-stream operand. This allows
constructs such as \code{a = 47+InPort(12, 8)} to be used as a shorthand for \code{a =
Repeater(47)+InPort("in", 8)} or \code{count = Counter(1, 10, 1)+3*2} to be used as
a shorthand for \code{count = Counter(1, 10, 1)+Repeater(5)}.  Of course \code{a=1+1}
still yields the integer 2 rather than a stream.

The operators provided in the Python Streams library are summarised in the
table below. The bit width field specifies how many bits are used for the
result based on the number of bits in the left and right hand operands.

\begin{tabulary}{\textwidth}{|L|L|L|}
\hline
\textbf{
Operator
} & \textbf{
Function
} & \textbf{
Data Width (bits)
}\\
\hline

+
 & 
Signed Add
 & 
max(left, right) + 1
\\

-
 & 
Signed Subtract
 & 
max(left, right) + 1
\\

*
 & 
Signed Multiply
 & 
left + right
\\

//
 & 
Signed Floor Division
 & 
max(left, right) + 1
\\

\%
 & 
Signed Modulo
 & 
max(left, right)
\\

\&
 & 
Bitwise AND
 & 
max(left, right)
\\

\textbar{}
 & 
Bitwise OR
 & 
max(left, right)
\\

\textasciicircum{}
 & 
Bitwise XOR
 & 
max(left, right)
\\

\textless{}\textless{}
 & 
Arithmetic Left Shift
 & 
left
\\

\textgreater{}\textgreater{}
 & 
Arithmetic Right Shift
 & 
left
\\

==
 & 
Equality Comparison
 & 
1
\\

!=
 & 
Inequality Comparison
 & 
1
\\

\textless{}
 & 
Signed Less Than
Comparison
 & 
1
\\

\textless{}=
 & 
Signed Less Than or Equal
Comparison
 & 
1
\\

\textgreater{}
 & 
Signed Greater Than
Comparison
 & 
1
\\

\textgreater{}=
 & 
Signed Greater Than
Comparison
 & 
1
\\
\hline
\end{tabulary}



\subsection{Operator Precedence}

The operator precedence is inherited from the python language. The following
table summarizes the operator precedences, from lowest precedence (least
binding) to highest precedence (most binding). Operators in the same row have
the same precedence.

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operator
} & \textbf{
Description
}\\
\hline

==, !=, \textless{}, \textless{}=, \textgreater{}, \textgreater{}=
 & 
Comparisons
\\
{\raggedright{}~}
 & 
Bitwise OR
\\

\textasciicircum{}
 & 
Bitwise XOR
\\

\&
 & 
Bitwise AND
\\

\textless{}\textless{}, \textgreater{}\textgreater{}
 & 
Shifts
\\

+, -
 & 
Addition and subtraction
\\

{\color{red}\bfseries{}*}, //, \%
 & 
multiplication, division and modulo
\\
\hline
\end{tabulary}



\subsection{Streams Reference}
\index{Array (class in chips)}

\hypertarget{chips.Array}{}\begin{classdesc}{Array}{address\_in, data\_in, address\_out, depth}\end{classdesc}
\index{Counter (class in chips)}

\hypertarget{chips.Counter}{}\begin{classdesc}{Counter}{start, stop, step}
A Stream which yields numbers from \emph{start} to \emph{stop} in \emph{step} increments.

A \emph{Counter} is a versatile, and commonly used construct in device design,
they can be used to number samples, index memories and so on.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c}{\# --\textgreater{} 0 2 4 6 8 10 0 \PYGZbs{}..}

\PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c}{\# --\textgreater{} 10 8 7 6 4 2 0 10 \PYGZbs{}..}
\end{Verbatim}
\end{classdesc}
\index{Decoupler (class in chips)}

\hypertarget{chips.Decoupler}{}\begin{classdesc}{Decoupler}{source}\end{classdesc}
\index{Resizer (class in chips)}

\hypertarget{chips.Resizer}{}\begin{classdesc}{Resizer}{source, bits}\end{classdesc}
\index{Lookup (class in chips)}

\hypertarget{chips.Lookup}{}\begin{classdesc}{Lookup}{source, *args}\end{classdesc}
\index{Fifo (class in chips)}

\hypertarget{chips.Fifo}{}\begin{classdesc}{Fifo}{data\_in, depth}\end{classdesc}
\index{Repeater (class in chips)}

\hypertarget{chips.Repeater}{}\begin{classdesc}{Repeater}{value}
A stream which repeatedly yields the specified \emph{value}.

The \emph{Repeater} stream is one of the most fundamental streams available.

The width of the stream in bits is calculated automatically. The smallest
number of bits that can represent \emph{value} in twos-complement format will be
used.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c}{\#--\textgreater{} 5 5 5 5 \PYGZbs{}..}
\PYG{c}{\#creates a 4 bit stream.}

\PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c}{\#--\textgreater{} 10 10 10 10 \PYGZbs{}..}
\PYG{c}{\#creates a 5 bit stream.}

\PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{c}{\#--\textgreater{} 10 10 10 10 \PYGZbs{}..}
\PYG{c}{\#This is shothand for: Repeater(5)*Repeater(2)}
\end{Verbatim}
\end{classdesc}
\index{Sequence (class in chips)}

\hypertarget{chips.Sequence}{}\begin{classdesc}{Sequence}{}\end{classdesc}
\index{Stimulus (class in chips)}

\hypertarget{chips.Stimulus}{}\begin{classdesc}{Stimulus}{bits}
A Stream that allows a Python iterable to be used as a stream.

A Simulus stream allows a transparent method to pass data from the Python
envrinment into the simulation environment. The sequence object is set at
run time using the set\_simulation\_data() method. The sequence object can be
any iterable Python sequence such as a list, tuple, or even a generator.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{PIL}

\PYG{n}{picture} \PYG{o}{=} \PYG{n}{Stimulus}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{picture}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{im} \PYG{o}{=} \PYG{n}{PIL}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{test.bmp}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{image\PYGZus{}data} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{im}\PYG{o}{.}\PYG{n}{getdata}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{picture}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}data}\PYG{p}{(}\PYG{n}{image\PYGZus{}data}\PYG{p}{)}

\PYG{n}{picture}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{picture}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{InPort (class in chips)}

\hypertarget{chips.InPort}{}\begin{classdesc}{InPort}{name, bits}
A device input port stream.

An \emph{InPort} allows a port pins of the target device to be used as a data
stream.  There is no handshaking on the input port. The port pins are
sampled at the point when data is transfered by the stream.  When
implemented in VHDL, the \emph{InPort} provides double registers on the port
pins to synchronise data to the local clock domain.

Since it is not possible to determine the width of the strean in bits
automatically, this must be specified using the \emph{bits} argument.

The \emph{name} parameter allows a string to be associated with the input port.
In a VHDL implementation, \emph{name} will be used as the port name in the
top level entity.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dip\PYGZus{}switches} \PYG{o}{=} \PYG{n}{Inport}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{dip\PYGZus{}switches}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)} 
\PYG{n}{s} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{SerialOut}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{dip\PYGZus{}switches}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{SerialIn (class in chips)}

\hypertarget{chips.SerialIn}{}\begin{classdesc}{SerialIn}{name='RX', clock\_rate=50000000, baud\_rate=115200}
A \emph{SerialIn} yields 8-bit data from a serial uart input.
\end{classdesc}
\index{Output (class in chips)}

\hypertarget{chips.Output}{}\begin{classdesc}{Output}{}\end{classdesc}
\index{Printer (class in chips)}

\hypertarget{chips.Printer}{}\begin{classdesc}{Printer}{source}\end{classdesc}
\index{HexPrinter (class in chips)}

\hypertarget{chips.HexPrinter}{}\begin{classdesc}{HexPrinter}{source}\end{classdesc}
\index{Scanner (class in chips)}

\hypertarget{chips.Scanner}{}\begin{classdesc}{Scanner}{}\end{classdesc}


\section{Sinks}
\index{chips.sinks (module)}
\hypertarget{module-chips.sinks}{}
\declaremodule[chips.sinks]{}{chips.sinks}
\modulesynopsis{}
Sinks are a fundamental component of the \emph{Chips} library.
\begin{description}
\item[{A sink is used to terminate a stream. A sink may act as:}] \leavevmode\begin{itemize}
\item {} 
An output of a \emph{Chip} such as an \emph{OutPort} or \emph{SerialOut}.

\item {} 
A consumer of data in its own right such as an \emph{Asserter}.

\end{itemize}

\end{description}


\section{Sinks Reference}
\index{Response (class in chips)}

\hypertarget{chips.Response}{}\begin{classdesc}{Response}{a}
A Response block allows data to be read from a stream in the python 
design environment. A similar interface can be used in native python
simulations and also co-simulations using external tools.
\end{classdesc}
\index{OutPort (class in chips)}

\hypertarget{chips.OutPort}{}\begin{classdesc}{OutPort}{a, name}\end{classdesc}
\index{SerialOut (class in chips)}

\hypertarget{chips.SerialOut}{}\begin{classdesc}{SerialOut}{a, name='TX', clock\_rate=50000000, baud\_rate=115200}\end{classdesc}
\index{Asserter (class in chips)}

\hypertarget{chips.Asserter}{}\begin{classdesc}{Asserter}{a}\end{classdesc}
\index{Console (class in chips)}

\hypertarget{chips.Console}{}\begin{classdesc}{Console}{a}\end{classdesc}


\section{Instructions}
\index{chips.instruction (module)}
\hypertarget{module-chips.instruction}{}
\declaremodule[chips.instruction]{}{chips.instruction}
\modulesynopsis{}
The instructions provided here form the basis of the software that can be run inside \emph{Processes}.


\subsection{Instructions Reference}
\index{Block (class in chips)}

\hypertarget{chips.Block}{}\begin{classdesc}{Block}{instructions}
The \emph{Block} statement allows instructions to be nested into a single
statement. Using a \emph{Block} allows a group of instructions to be stored as a
single object.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{intialise} \PYG{o}{=} \PYG{n}{Block}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
    \PYG{n}{initialise}\PYG{p}{,}
    \PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{initialise}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Break (class in chips)}

\hypertarget{chips.Break}{}\begin{classdesc}{Break}{}
The \emph{Break} statement causes the flow of control to immediately exit the loop.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#equivilent to a While loop}
\PYG{n}{Loop}\PYG{p}{(}
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{condition} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{,}
        \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{c}{\#do stuff here}
\PYG{p}{)}\PYG{p}{,}
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#equivilent to a DoWhile loop}
\PYG{n}{Loop}\PYG{p}{(}
    \PYG{c}{\#do stuff here}
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{condition} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{,}
        \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}\PYG{p}{,}
\end{Verbatim}
\end{classdesc}
\index{Continue (class in chips)}

\hypertarget{chips.Continue}{}\begin{classdesc}{Continue}{}
The \emph{Continue} statement causes the flow of control to immediately jump to
the next iteration of the contatining loop.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}
    \PYG{n}{Loop}\PYG{p}{(}
        \PYG{n}{in\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{If}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\&}\PYG{l+m+mi}{1}\PYG{p}{,}
            \PYG{n}{Continue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{)}\PYG{p}{,}
        \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{If (class in chips)}

\hypertarget{chips.If}{}\begin{classdesc}{If}{condition, *instructions}
The \emph{If} statement conditionaly executes instructions.

The condition of the \emph{If} branch is evaluated, followed by the condition of
each of the optional \emph{ElsIf} branches. If one of the conditions evaluates
to non-zero then the corresponding instructions will be executed. If the
\emph{If} condition, and all of the \emph{ElsIf} conditions evaluate to zero, then
the instructions in the optional \emph{Else} branch will be evaluated.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{If}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,}
    \PYG{c}{\#do something}
\PYG{p}{)}\PYG{o}{.}\PYG{n}{Elsif}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,}
    \PYG{c}{\#do something else}
\PYG{p}{)}\PYG{o}{.}\PYG{n}{Else}\PYG{p}{(}
    \PYG{c}{\#if all else fails do this}
\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Loop (class in chips)}

\hypertarget{chips.Loop}{}\begin{classdesc}{Loop}{*instructions}
The \emph{Loop} statement executes instructions repeatedly.

A \emph{Loop} can be exited using the \emph{Break} instruction. A \emph{Continue}
instruction causes the remainder of intructions in the loop to be skipped.
Execution then repeats from the begining of the \emph{Loop}.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#filter filter values over 50 out of a stream}
\PYG{n}{Loop}\PYG{p}{(}
    \PYG{n}{in\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{Continue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}\PYG{p}{,}
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#initialise an array}
\PYG{n}{Loop}\PYG{p}{(}
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{index} \PYG{o}{==} \PYG{l+m+mi}{100}\PYG{p}{,}
        \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{n}{myarray}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}\PYG{p}{,}
\end{Verbatim}
\end{classdesc}
\index{Value (class in chips)}

\hypertarget{chips.Value}{}\begin{classdesc}{Value}{expression}
The \emph{Value} statement gives a value to the surrounding \emph{Evaluate}
construct.

An \emph{Evaluate}  expression allows a block of statements to be used as an
expression. When a \emph{Value} is encountered, the supplied expression becomes
the value of the whole evaluate statement.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#provide a And expression similar to Pythons and expression}
\PYG{k}{def} \PYG{n+nf}{LogicalAnd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{Evaluate}\PYG{p}{(}
        \PYG{n}{If}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}
            \PYG{n}{Value}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{)}\PYG{o}{.}\PYG{n}{Else}\PYG{p}{(}
            \PYG{l+m+mi}{0}\PYG{p}{,}
        \PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{WaitUs (class in chips)}

\hypertarget{chips.WaitUs}{}\begin{classdesc}{WaitUs}{}
\emph{WaitUs} causes execution to halt until the next tick of the microsecond
timer.

In practice, this means that the the process is stalled for less than 1
microsecond. This behaviour is usefull when implementing a real-time
counter function because the execution time of statements does not affect
the time between \emph{WaitUs} statements (Providing the statements do not take
more than 1 microsecond to execute of course!).

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{seconds} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}
    \PYG{n}{seconds}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{Loop}\PYG{p}{(}
        \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,}
            \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
            \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{)}\PYG{p}{,}
        \PYG{n}{seconds}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{seconds} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{seconds}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{While (class in chips)}

\hypertarget{chips.While}{}\begin{classdesc}{While}{}\end{classdesc}
\index{Scan (class in chips)}

\hypertarget{chips.Scan}{}\begin{classdesc}{Scan}{stream, variable}\end{classdesc}
\index{Print (class in chips)}

\hypertarget{chips.Print}{}\begin{classdesc}{Print}{stream, exp, minimum\_number\_of\_digits=None}\end{classdesc}
\index{Evaluate (class in chips)}

\hypertarget{chips.Evaluate}{}\begin{classdesc}{Evaluate}{*instructions}\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-automatic\_code\_generation/index}{}

\chapter{Automatic Code Generation}


\section{VHDL Code Generation}


\section{C++ Code Generation}
\index{chips\_cpp (module)}
\hypertarget{module-chips\_cpp}{}
\declaremodule[chipscpp]{}{chips\_cpp}
\modulesynopsis{}
C++ code generator for streams library


\section{Visualisation Code Generation}


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\item {} 
\emph{Search Page}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
