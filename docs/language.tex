Chip ========

Streams} \subsection{Counter(Start, Stop, Step)} This versatile Stream emits
numbers in the sequence $[start, start + step, start + 2 * step, ..., stop,
start, ...]$.


\begin{verbatim}
Example
Counter(1, 3, 1)
=> [1, 2, 3, 1, 2, 3, 1, 2, 3, ...,]
Counter(3, 1, -1)
=> [3, 2, 1, 3, 2, 1 ...,]
\end{verbatim}

\subsection{InPort(name, bits)}
The \verb|InPort| Stream emits numbers aquired from a physical io port in a
target device.

\verb|name| is a string parameter specifying a name to identify
the port in the target implementation.

Since it is not possible to automatically determine the number of bits needed,
the width of the port must be explicitly set using the \verb|bits| parameter.

No handshaking is implemented, the value emited by an
\verb|InPort| Stream is the value present on the io port at the time the
stream transaction completes. The \verb|InPort| Stream will automatically
generate logic to synchronise the io port to the local clock domain.

Example:
\begin{verbatim}
Example
1  dip_switch = InPort("sw0", 8)
2  minimal_system = System(OutPort("led0", dip_switch))
\end{verbatim}

\subsection{Output()}
While inputs to a process are created implicitly by reading from a stream,
process outputs must be explicitly created by creating an \verb|Output|.

::
	output1 = Output()
	output2 = Output()
	data = Variable(0)
	Process(bits,
	  Loop(
	    stream.read(data),
	    stream.write(output1),
	    stream.write(output2),
	  )
	)

\label{Repeater}
\subsection{Repeater(value)}
The \verb|Repeater| Stream emits \verb|value| repeatedly.

\begin{verbatim}
Example
a = Repeater(1) + Repeater(1)
=> [2, 2, 2, 2, 2, 2, 2 ...]
\end{verbatim}

\subsection{Scanner()}

\subsection{Sequence(seqeunce)}
The \verb|Sequence| Stream emits each item in \verb|sequence| in turn. When the
end of the sequence is reached, the whole process repeates starting again from
the first item.

\begin{verbatim}
Example
Sequence(0, l, l, 3, 4)
=> [0, 1, 1, 3, 4, 0, 1, 1 ...]
\end{verbatim}

\subsection{SerialIn}
\subsection{Stimulus}

\section{Stream Combinators}
\subsection{Array}
\subsection{Decoupler}
\subsection{HexPrinter}
\subsection{Lookup}
\subsection{Printer}
\subsection{Process}
\label{Resizer}
\subsection{Resizer}

\section{Stream Expressions}

A Stream Expression can be formed by combining Streams or Stream Expressions
with the following ooperators: 
\begin{verbatim}
+, -, *, \/, %, &, |, ^, <<, >>, ==, !=, <, <=, >, >=
\end{verbatim}
Each data item in the resulting Stream Expression will be evaluated by removing
a data item from each of the operand streams, and applying the operator function
to these data items.

Generaly speaking a Stream Expression will have enough bits to contain any
possible result without any arithmetic overflow. The one exception to this is
the left shift operator where the result is always truncated to the size of the
left hand operand. Stream expressions may be explicitly truncated or sign
extended using the \verb|Resizer| (section \ref{Resizer}).

If one of the operands of a binary operator is not a Stream, Python Streams
will attempt to convert this operand into an integer. If the conversion is
successfull, a \verb|Repeater| (section \ref{Repeater}) stream will be created
using the integer value. The repeater stream will be used in place of the
non-stream operand. This allows constructs such as \verb|a = 47+InPort(12, 8)|
to be used as a shorthand for \verb|a = Repeater(47)+InPort(12, 8)| or
\verb|count = Counter(1, 10, 1)+3*2| to be used as a shorthand for
\verb|count = Counter(1, 10, 1)+Repeater(5)|.
Of course \verb|a=1+1| still yields the integer 2 rather than a stream.

The operators provided in the Python Streams library are summarised in the table
below. The bit width field specifies how many bits are used for the result
based on the number of bits in the left and right hand operands.

\begin{table}[h]
\begin{center}
\begin{tabular}[]{cll}
\textbf{Operator} & \textbf{Function}            & \textbf{Bit Width}\\
\verb$+$          & Signed Add                   & $max(left, right) + 1$\\
\verb$-$          & Signed Subtract              & $max(left, right) + 1$\\
\verb$*$          & Signed Multiply              & $left + right$\\
\verb$//$         & Signed Floor Division        & $max(left, right) + 1$\\
\verb$%$          & Signed Modulo                & $max(left, right)$\\
\verb$&$          & Bitwise AND                  & $max(left, right)$\\
\verb$|$          & Bitwise OR                   & $max(left, right)$\\
\verb$^$          & Bitwise XOR                  & $max(left, right)$\\
\verb$<<$         & Arithmetic Left Shift                   & $left$\\
\verb$>>$         & Arithmetic Right Shift                  & $left$\\
\verb$==$         & Equality Comparison                     & $1$\\
\verb$!=$         & Inequality Comparison                   & $1$\\
\verb$<$          & Signed Less Than Comparison             & $1$\\
\verb$<=$         & Signed Less Than or Equal Comparison    & $1$\\
\verb$>$          & Signed Greater Than Comparison          & $1$\\
\verb$>=$         & Signed Greater Than or Equal Comparison & $1$\\
\end{tabular}
\end{center}
\caption{Operator summary}
\end{table}

\subsection{operator precedence}
The operator precedence is inherited from the python language. The following
table summarizes the operator precedences, from lowest precedence (least
binding) to highest precedence (most binding). Operators in the same row have
the same precedence.

  \begin{center} \begin{tabular}{ll} \textbf{Operator} & \textbf{Description}\\
\verb$==, !=, <, <=, >, >=$ & Comparisons\\ \verb$|$ & Bitwise OR\\ \verb$^$ &
Bitwise XOR\\ \verb$&$ & Bitwise AND\\ \verb$<<, >>$ & Shifts\\ \verb$+, -$ &
Addition and subtraction\\ \verb$*, //, %$ & multiplication, division and modulo
\end{tabular} \end{center} \caption{Operator precedence} \end{table}

\section{Sinks}
\subsection{Asserter}
\subsection{Console}
\subsection{OutPort}
\subsection{Response}
\subsection{SerialOut}
\subsection{SVGA}

\section{Processes}
\subsection{Output}
\subsection{Variable}
\subsection{VariableArray}
\section{Process Statements}
\subsection{Block}
\subsection{Break}
\subsection{Constant}
\subsection{Continue}
\subsection{DoUntil}
\subsection{DoWhile}
\subsection{Evaluate}
\subsection{If}
\subsection{Loop}
\subsection{Print}
\subsection{Scan}
\subsection{Until}
\subsection{Value}
\subsection{Variable}
\subsection{WaitUs}
\subsection{While}
\subsection{Expressions}

\section{Process Expressions}

\section{Patterns of Use}
