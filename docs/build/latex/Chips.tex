% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{Chips Documentation}
\date{April 29, 2011}
\release{0.1}
\author{Jonathan P Dawson}
\newcommand{\sphinxlogo}{\includegraphics{chips.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\hypertarget{--doc-index}{}



\chapter{What is Chips?}

Chips is a Python library that provides a language for designing hardware
devices.


\chapter{Features}

Some of the key features include:
\begin{itemize}
\item {} 
High level modeling language makes device design simpler and more
powerful.

\item {} 
An open source hardware design environment.

\item {} 
Provides fast native simulations that integrate with Python.

\item {} 
Exploit Python extension modules such as Scipy, Numpy, Matplotlib and PIL
provide a rich verification environment.

\item {} 
Automatic generation of synthesizable VHDL.

\item {} 
Plugin mechanism also allows C++ and graphviz outputs to be generated.

\item {} 
Existing VHDL IP can be imported.

\item {} 
Seamless co-simulation of C++ and VHDL outputs.

\end{itemize}


\chapter{A Quick Taster}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#4 bit linear feedback shift register}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{new\PYGZus{}bit} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{shift\PYGZus{}register} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c}{\#initialise to anything but 0}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{output\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{...}
\PYG{g+gp}{... }        \PYG{c}{\#tap off bit 2 and 3}
\PYG{g+gp}{... }        \PYG{n}{new\PYGZus{}bit}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{p}{(}\PYG{n}{shift\PYGZus{}register} \PYG{o}{\textgreater{}\textgreater{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZca{}} \PYG{p}{(}\PYG{n}{shift\PYGZus{}register} \PYG{o}{\textgreater{}\textgreater{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZca{}} \PYG{n}{new\PYGZus{}bit}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{...}
\PYG{g+gp}{... }        \PYG{c}{\#implement shift register}
\PYG{g+gp}{... }        \PYG{n}{shift\PYGZus{}register}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{new\PYGZus{}bit} \PYG{o}{\&} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\textless{}\textless{}} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{shift\PYGZus{}register} \PYG{o}{\textgreater{}\textgreater{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{...}
\PYG{g+gp}{... }        \PYG{c}{\#4 bit mask}
\PYG{g+gp}{... }        \PYG{n}{shift\PYGZus{}register}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{shift\PYGZus{}register} \PYG{o}{\&} \PYG{l+m+mh}{0xf}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{...}
\PYG{g+gp}{... }        \PYG{c}{\#write to stream}
\PYG{g+gp}{... }        \PYG{n}{output\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{shift\PYGZus{}register}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{device} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{output\PYGZus{}stream}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{device}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{device}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+go}{12}
\PYG{g+go}{14}
\PYG{g+go}{7}
\PYG{g+go}{3}
\PYG{g+go}{1}
\PYG{g+gp}{...}
\end{Verbatim}


\chapter{Download}

You can download the \href{https://github.com/downloads/dawsonjon/chips/Chips-0.1.tar.gz}{source distribution} or the \href{https://github.com/downloads/dawsonjon/chips/Chips-0.1.win32.exe}{windows  installer} from
the \href{http://github.com/dawsonjon/chips/}{GitHub} homepage.


\chapter{Documentation}

\resetcurrentobjects
\hypertarget{--doc-introduction/index}{}

\section{Introduction}

The Chips library gives Python the ability to design, simulate and realise
digital devices such as FPGAs. Chips provides a simple yet powerful suite of
primitive components, \emph{Streams}, \emph{Processes} and \emph{Sinks} that can be
succinctly combined to form \emph{Chips}. The \emph{Chips} library can automatically
convert \emph{Streams}, \emph{Processes} and \emph{Sinks} into a Hardware Description
Language, which can be synthesised into real hardware.

Python programs cannot themselves be converted into real hardware, but it is
possible to programmatically generate which construct \emph{Chips}, which can
in-turn be converted into hardware. When combined with the extensive
libraries already supported by Python, such as NumPy and SciPy, Python and
Chips make the ideal design and verification environment.


\subsection{A new approach to device design}

Traditionally, the tool of choice for digital devices is a Hardware
Description Language (HDL), the most common being Verilog and VHDL. These
languages provide a reasonably rich environment for modeling and simulating
hardware, but only a limited subset of the language can be realised in a
digital device (synthesised).

While a software designer would typically implement a function in an
imperative style using loops, branches and sub procedures; a hardware model
written in an imperative style cannot be synthesised.

Synthesizable designs require a different approach. Digital device designers
must work at the Register Transfer Level (RTL). The primitive elements of an
RTL design are clocked memory elements (registers) and combinational logic
elements. A typical synthesis tool would be able to infer boolean logic,
addition, subtraction, multiplexing and bit manipulation from HDL code
written in a very specific style.

An RTL designer has to work at a low level of abstraction. In practical
terms this means that a designer has to do more of the work themselves.
\begin{enumerate}
\item {} 
A designer is responsible for designing their own interfaces to
the outside world.

\item {} 
The designer is responsible for clock to clock timing, manually
balancing propagation delays between clocked elements to achieve
high performance.

\item {} 
A designer has to provide their own mechanism to synchronise and
pass data between concurrent computational elements (by
implementing a bus with control and handshaking signals).

\item {} 
A designer has to provide their own mechanism to control the flow
of execution within a computational element (usually by manually
coding a finite state machine).

\item {} 
The primitive elements are primitive. Synthesis tools provide
limited support for multiplication, and division is not usually
supported at all.

\end{enumerate}

This is where \emph{Python Chips} comes in. In \emph{Python Chips}, there is no
synthesizable subset, but a standalone synthesizable language built on top
of Python. \emph{Python Chips} allows designers to work at a higher level of
abstraction. It does a lot more of the work for you.
\begin{enumerate}
\item {} 
\emph{Python Chips} provides a suite of device interfaces including
I/O ports and UARTs.

\item {} 
Synthesizable RTL code is generated automatically by the tool.
Clocks, resets, and clock to clock timing are all taken care of
behind the scenes.

\item {} 
\emph{Python Chips} provides a simple method to synchronise concurrent
elements, and to pass data between them - streams. The tool
automatically generates interconnect buses and handshaking
signals behind the scenes.

\item {} 
\emph{Python Chips} provides processes with imperative style
sequences branches and loop. The tool automatically generates
state machines, or highly optimized soft-core processors behind
the scenes.

\item {} 
The primitive elements are not so primitive. Common constructs
such as counters, lookup tables, ROMS and RAMS are invoked with a
single keyword and a few parameters. \emph{Python Chips} also provides
a richer set of arithmetic operators including fully
synthesizable division and multiplication.

\end{enumerate}


\subsection{A language within a language}

\emph{Python Chips} is a python library, just an add-on to Python which is no
more or less than a programming language. The \emph{Python Chips} library
provides an Application Programmers Interface (API) to a suite of hardware
design functions.

The \emph{Python Chips} library can also be considered a language in its own
right, The Python language itself provides statements which are executed on
your own computer. The \emph{Python Chips} provides an alternative language,
statements which are executed on the target device.

\resetcurrentobjects
\hypertarget{--doc-tutorial/index}{}

\section{Tutorial}


\subsection{Learn Python}

In order to make any real use of the \emph{Chips} library you will need to be
familiar with the basics of \emph{Python}. The \href{http://docs.python.org/tut}{Python tutorial} is a good place
to start.


\subsection{Install Chips}


\subsubsection{Windows}
\begin{enumerate}
\item {} 
First \href{http://python.org/download}{install Python}. You need \emph{Python} 2.6 or later, but not \emph{Python} 3.

\item {} 
Then install the \emph{Chips} library from the \href{https://github.com/downloads/dawsonjon/chips/Chips-0.1.win32.exe}{windows installer}.

\end{enumerate}


\subsubsection{Linux}
\begin{enumerate}
\item {} 
First \href{http://python.org/download}{install Python}. You need \emph{Python} 2.6 or later, but not \emph{Python} 3.

\item {} 
Then install the \emph{Chips} library from the \href{https://github.com/downloads/dawsonjon/chips/Chips-0.1.tar.gz}{source distribution}:

\begin{Verbatim}[commandchars=@\[\]]
desktop:@textasciitilde[]@$ tar -zxf chips-0.1.tar.gz
desktop:@textasciitilde[]@$ cd chips-0.1
desktop:@textasciitilde[]@$ python setup.py install @#run as root
\end{Verbatim}

\end{enumerate}


\subsection{First Simulations}

Once you have \emph{Python} and \emph{Chips} all set up, you can start with some simple
examples. This one counts to 10 repeatedly:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#create a chip model}
\PYG{g+gp}{... }\PYG{n}{my\PYGZus{}chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#run a simulation}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{4}
\PYG{g+go}{5}
\PYG{g+go}{6}
\PYG{g+go}{7}
\PYG{g+go}{8}
\PYG{g+go}{9}
\PYG{g+go}{10}
\PYG{g+go}{0}
\PYG{g+gp}{...}
\end{Verbatim}

The example can be broken down as follows:
\begin{itemize}
\item {} 
\code{from stream import *} adds the basic features of the streams
library to the local namespace.

\item {} 
A \emph{Chip} models a target device. You need to tell it what the outputs
(sinks) are, but it will work out what the inputs are by itself. In
this case the only sink is the \emph{Console}.

\item {} 
A \emph{Console} is a sink that outputs a stream of data to the console.
The only argument it needs is the data stream, \emph{Printer}.

\item {} 
A \emph{Printer} is a stream object that represents a stream of data in
decimal format as a string of ASCII characters. A \emph{Printer} is not a
source of data in itself, it transforms a stream of data that you
supply, the \emph{Counter}.

\item {} 
The \emph{Counter} is a fundamental data stream. It accepts three
arguments: start, stop and step. The \emph{Counter} will yield a stream of
data counting from \emph{start} to \emph{stop} in \emph{step} increments.

\end{itemize}


\subsection{Hello World}

No language would be complete without a ``hello world'' example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#run a simulation}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{hello world}
\PYG{g+go}{hello world}
\PYG{g+go}{hello world}
\PYG{g+gp}{...}
\end{Verbatim}

In this example we have made only a few changes:
\begin{itemize}
\item {} 
\code{map(ord, "hello world\textbackslash{}n")} creates a list containing the numeric values of
the ASCII characters in a string.

\item {} 
This example introduces a new stream, the \emph{Sequence}. The \emph{Sequence} stream
outputs each of its arguments in turn, when the arguments are exhausted, the
\emph{Process} repeats.

\item {} 
A \emph{Printer} is stream is not needed in this example since the stream is
already a sequence of ASCII values.

\end{itemize}


\subsection{Generating VHDL}

Now lets consider how the ``hello world'' example could be implemented in an
actual device. A first step to implementing a device would be to generate a
VHDL model:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips.VHDL\PYGZus{}plugin} \PYG{k+kn}{import} \PYG{n}{Plugin}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{hello\PYGZus{}world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#generate a VHDL model}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{code\PYGZus{}generator} \PYG{o}{=} \PYG{n}{Plugin}\PYG{p}{(}\PYG{n}{project\PYGZus{}name}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip}\PYG{o}{.}\PYG{n}{write\PYGZus{}code}\PYG{p}{(}\PYG{n}{code\PYGZus{}generator}\PYG{p}{)}
\end{Verbatim}

The \emph{Chips} library uses plugins to generate output code from models. This
means that new code generators can be added to \emph{Chips} without having to
change the way that hardware is designed and simulated. At present, \emph{Chips}
supports C++ and VHDL code generation, but it is VHDL code that allows
\emph{Chips} to be synthesised.

The VHDL code generation plugin is found in \code{chips.VHDL\_plugin} if you run
this example you should find that a VHDL file called hello\_world.vhd has been
generated.

Take a look through this file. you may find that it is difficult to
understand what is going on. the file isn't meant to be read by humans, \emph{Chips}
treats VHDL as a compatibility layer. \emph{VHDL} is pretty much universally
supported by synthesis tools.  You can run this code in an external VHDL
simulator, but you won't be able to synthesise it into a device because real
hardware devices don't have a concept of a \emph{Console}.

To make this example synthesise, we need to write the characters to some
realisable hardware interface. The \emph{Chips} library provides a \emph{SerialOut}
sink, this provides a simple way to direct the stream of characters to a
serial port:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips.VHDL\PYGZus{}plugin} \PYG{k+kn}{import} \PYG{n}{Plugin}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{SerialOut}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{hello\PYGZus{}world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#generate a vhdl model}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{code\PYGZus{}generator} \PYG{o}{=} \PYG{n}{Plugin}\PYG{p}{(}\PYG{n}{project\PYGZus{}name}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip}\PYG{o}{.}\PYG{n}{write\PYGZus{}code}\PYG{p}{(}\PYG{n}{code\PYGZus{}generator}\PYG{p}{)}
\end{Verbatim}

Now you should have a hello\_world.vhd file that you can synthesise in a real
device. By default, SerialOut will assume that you are using a 50 MHz clock
and a baud rate of 115200. If you need something else you can use the
clock\_rate and baud\_rate arguments to specify what you need.


\subsection{More Streams and Sinks}

So far we have seen three types of streams, \emph{Counter}, \emph{Sequence} and
\emph{Printer}. \emph{Chips} provides a range of streams. The full documentation for
streams is in the \href{http://dawsonjon.github.com/chips/language\_reference/}{reference manual} but a quick summary is included here:

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Stream
} & \textbf{
Description
}\\
\hline

Array()
 & 
An indexable memory with an independent read and write
port.
\\

Counter()
 & 
A versatile counter with min, max and step parameters
\\

Decoupler()
 & 
A Decoupler removes stream handshaking.
\\

Resizer()
 & 
A Resizer changes the width, in bits, of the source
stream.
\\

Lookup()
 & 
An indexable Read Only Memory with a single read port.
\\

Fifo()
 & 
Stores data items in a buffer.
\\

Repeater()
 & 
Yields the same data item repeatedly.
\\

InPort()
 & 
Yields the value of input port pins.
\\

SerialIn()
 & 
Yields values from a serial UART.
\\

Output()
 & 
A stream that is fed by a \emph{Process} (more on this later)
\\

Printer()
 & 
A decimal ASCII representation of the source stream.
\\

HexPrinter()
 & 
A hexadecimal ASCII representation of the source stream.
\\

Scanner()
 & 
yields the value of the decimal ASCII source stream.
\\
\hline
\end{tabulary}


You can also combine streams using the operators : \code{abs, \textasciitilde{}, +, -, *, //, \%,
\textless{}\textless{}, \textgreater{}\textgreater{}, \&, \textbar{}, \textasciicircum{}, ==, !=, \textless{}, \textless{}=, \textgreater{}, \textgreater{}=} on the whole they have the same (or
very similar) meaning as they do in \emph{Python} except that they operate on streams
of data. It is also possible to form an expression from regular integers and
streams, \emph{Chips} will automatically transform an integer into an appropriate
\emph{Repeater} stream. For example \code{Counter(0, 9, 1)*2} is a shorthand for
\code{Counter(0, 9, 1)*Repeater(2).}

The following table summarises the available sinks:

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Sink
} & \textbf{
Description
}\\
\hline

Response()
 & 
A Response sink allows data to be transfered into
Python.
\\

OutPort()
 & 
An OutPort sink outputs a stream of data to I/O port
pins.
\\

SerialOut()
 & 
A SerialOut outputs data to a serial UART port.
\\

Asserter()
 & 
An Asserter causes an exception if any data in the
source stream is zero.
\\

Console()
 & 
A Console outputs data to the simulation console.
\\
\hline
\end{tabulary}

\begin{quote}
\end{quote}


\subsection{Types and Bit Width}

For convenience, the central numerical type in \emph{Chips} is a signed integer with
a fixed number of bits.  This is in contrast to \emph{Python}, where integers have a
potentially infinite width. \emph{Chips} tries to simplify some of the design issues
involved with limited width numbers by doing a lot of the work for you, but it
is not always possible to completely hide these details, so you need to how
things are handled behind the scenes.

\emph{Chips} will automatically determine the width of a stream whenever possible.
In a \emph{Repeater}, \emph{Counter} or \emph{Lookup}, \emph{Chips} will chose use the number of
bits needed to hold the greatest possible value. This is not possible for
\emph{InPort}, or \emph{Array} streams because the maximum possible value is not known at
compile time. When it is not possible to determine the maximum value, the width
must be specified using the bits parameter.

When streams are combined using operators, the width of the resulting stream
will usually be chosen to handle the maximum possible value in the resulting
stream, though there are some exceptions. Adding two 8 bit streams will result
in a 9 bit stream, multiplying two 8 bit streams will result in a 16 bit
stream. The precise handling of bit widths is documented more  fully in the
\href{http://dawsonjon.github.com/chips/language\_reference/}{reference manual}.

You can manually change the width of a stream using the \emph{Resize} stream. Making
a streams smaller in width will result in large values being truncated. Making
a stream larger in width will result in sign extension.
\begin{quote}
\end{quote}


\subsection{Introducing Processes}

We have seen how the \emph{Chips} library provides quite a few ready made streams
out of the box. Sometimes these streams won't suite our needs, sometimes we
need to define new operations on streams. Suppose we wanted to double the value
of every data item within in an existing stream, a Counter say. Thats easy,
just use the multiply operator \code{Counter(0, 9, 1)*2}. Now suppose that we
wanted to square each data item instead. Not so simple, there is no squaring
operator, or even a power operator for that matter. Thats where the \emph{Process}
comes in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{counter} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{c}{\#create a temporary variable and initialise it to 0.}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{counter\PYGZus{}squared\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p}\PYG{o}{=}\PYG{n}{Process}\PYG{p}{(}\PYG{n}{counter}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{counter}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{counter\PYGZus{}squared\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{o}{*}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{counter\PYGZus{}squared\PYGZus{}stream}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{4}
\PYG{g+go}{9}
\PYG{g+go}{16}
\PYG{g+go}{25}
\PYG{g+go}{36}
\PYG{g+gp}{...}
\end{Verbatim}

This example demonstrates some of the key features of the \emph{Process}:
\begin{itemize}
\item {} 
Put it simply, a \emph{Process} is small computer program which can contain loops
and if statements like any other language.

\item {} 
A \emph{Chip} can contain any number of Process objects, they will all run in
parallel.

\item {} 
Within a \emph{Process}, you can use \emph{Variables} to store data. Each variable can
only be used within one \emph{Process}, to communicate with another \emph{Process} you
need to use streams.

\item {} 
A \emph{Process} can read from any type of stream, in this example the process is
reading from a \emph{Counter} stream. Only \emph{Output} streams can be written to.

\item {} 
Streams can only be used for point to point communications. A stream cannot
be read by more than one \emph{Process}. Likewise, an \emph{Output} stream can only be
written to by one \emph{Process}.

\end{itemize}


\subsection{Process Instructions}

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Instruction
} & \textbf{
Description
}\\
\hline

Variable()
 & 
A Variable is used within a Process to store data.
\\

Value()
 & 
The Value statement gives a value to the surrounding
Evaluate construct.
\\

Evaluate()
 & 
An Evaluate  expression allows a block of statements
to be used as an expression.
\\

Loop()
 & 
The Loop statement executes instructions repeatedly.
\\

If()
 & 
The If statement conditionally executes
instructions.
\\

Break()
 & 
The Break statement causes the flow of control to
immediately exit the loop.
\\

WaitUs()
 & 
WaitUs causes execution to halt until the next tick
of the microsecond timer.
\\

Continue()
 & 
The Continue statement causes the flow of control to
immediately jump to the next iteration of the
containing loop.
\\

Block()
 & 
The Block statement allows instructions to be nested
into a single statement.
\\

Output.write()
 & 
This method returns a write instruction that writes a
single data item to the Output stream.
\\

\textless{}stream\textgreater{}.read()
 & 
This method returns a read instruction that reads a
single data item from a  stream.
\\

Variable.set()
 & 
This method returns a set instruction that assigns the
value of an expression to a variable.
\\
\hline
\end{tabulary}



\subsection{Bit Width Within a Process}

We have already seen how streams are usually sized automatically to handle the
largest possible data value. Inside a \emph{Process} however things are handled
differently. A \emph{Process} has a fixed bit width. The width is the first argument
given to a \emph{Process}. Inside a \emph{Process}, the value of any expression will be
resized the width of the \emph{Process}. When a \emph{Process} reads from a stream, the
value will be truncated or sign extended to the width of the \emph{Process}. It is
important to make sure that the width of a \emph{Process} is sufficiently large.


\subsection{Hierarchical Design}

You may be expecting \emph{Chips} to provide some mechanism for hierarchical design.
You might expect that \emph{Chips} would provide a means too group items together to
form re-usable components or modules. A really good design tool would allow you
to parameterise components and modules using generics or templates. \emph{Chips} does
not provide any of these things. It doesn't have to.

The \emph{Python} language itself already provides all these things and more. If you
want to make a reusable component you can simply write a \emph{Python} function:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{double}\PYG{p}{(}\PYG{n}{input\PYGZus{}stream}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{l+s+sd}{"""If you use Python functions to build components you can take}
\PYG{g+gp}{... }\PYG{l+s+sd}{    advantage of docstrings to document your design."""}
\PYG{g+gp}{...}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{input\PYGZus{}stream} \PYG{o}{*} \PYG{l+m+mi}{2}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{double}\PYG{p}{(}
\PYG{g+gp}{... }                \PYG{n}{Sequence}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{g+gp}{... }            \PYG{p}{)}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+go}{4}
\PYG{g+go}{6}
\PYG{g+go}{2}
\PYG{g+gp}{...}
\end{Verbatim}


\subsection{Streams from Multiple Sources}

Streams can only be have one source of data and one sink, but it is possible to
combine data from more than one source into a single stream using a \emph{Process}.
The simplest approach is to read a value from each source, and write it to the
destination thus:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{simple\PYGZus{}arbiter}\PYG{p}{(}\PYG{n}{source\PYGZus{}0}\PYG{p}{,} \PYG{n}{source\PYGZus{}1}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{l+s+sd}{"""Combine data from two streams into a single stream"""}
\PYG{g+gp}{... }    \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{dest} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{Process}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{[}\PYG{n}{source\PYGZus{}0}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{source\PYGZus{}1}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{source\PYGZus{}0}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{dest}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{source\PYGZus{}1}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{dest}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{dest}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }   \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }       \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }           \PYG{n}{simple\PYGZus{}arbiter}\PYG{p}{(}
\PYG{g+gp}{... }               \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{... }           \PYG{p}{)}
\PYG{g+gp}{... }       \PYG{p}{)}
\PYG{g+gp}{... }   \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+gp}{...}
\end{Verbatim}

This type of arbiter will always take an equal number of items from source\_0,
and source\_1. This may be fine in some applications, but if data were not
available on source\_0, data from source\_1 would also be blocked. One solution
is to use the \emph{available} method of a stream to test whether data is available
before committing to a blocking read:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{non\PYGZus{}blocking\PYGZus{}arbiter}\PYG{p}{(}\PYG{n}{source\PYGZus{}0}\PYG{p}{,} \PYG{n}{source\PYGZus{}1}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{l+s+sd}{"""Combine data from two streams into a single stream"""}
\PYG{g+gp}{... }   \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }   \PYG{n}{dest} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }   \PYG{n}{Process}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{[}\PYG{n}{source\PYGZus{}0}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{source\PYGZus{}1}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }       \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }           \PYG{n}{If}\PYG{p}{(}\PYG{n}{source\PYGZus{}0}\PYG{o}{.}\PYG{n}{available}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }               \PYG{n}{source\PYGZus{}0}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }               \PYG{n}{dest}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{n}{If}\PYG{p}{(}\PYG{n}{source\PYGZus{}1}\PYG{o}{.}\PYG{n}{available}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }               \PYG{n}{source\PYGZus{}1}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }               \PYG{n}{dest}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }           \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }       \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }   \PYG{p}{)}
\PYG{g+gp}{... }   \PYG{k}{return} \PYG{n}{dest}
\PYG{g+gp}{...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{blocked} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p}\PYG{o}{=}\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#outputs one value then blocks}
\PYG{g+gp}{... }    \PYG{n}{blocked}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{non\PYGZus{}blocking\PYGZus{}arbiter}\PYG{p}{(}
\PYG{g+gp}{... }                \PYG{n}{blocked}\PYG{p}{,} \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{... }            \PYG{p}{)}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{2}
\PYG{g+go}{2}
\PYG{g+gp}{...}
\end{Verbatim}


\subsection{Streams with Multiple Sinks}

Sometimes a stream will need to be used in more than one place. A simple
solution is to make a splitter or tee using a \emph{Process}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{tee}\PYG{p}{(}\PYG{n}{source}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{l+s+sd}{"""split data into two streams"""}
\PYG{g+gp}{... }    \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{dest\PYGZus{}0} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{dest\PYGZus{}1} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{Process}\PYG{p}{(}\PYG{n}{source}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{source}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{dest\PYGZus{}0}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{dest\PYGZus{}1}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{dest\PYGZus{}0}\PYG{p}{,} \PYG{n}{dest\PYGZus{}1}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dest\PYGZus{}0}\PYG{p}{,} \PYG{n}{dest\PYGZus{}1} \PYG{o}{=} \PYG{n}{tee}\PYG{p}{(}\PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{dest\PYGZus{}0}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{dest\PYGZus{}1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{3}
\PYG{g+gp}{...}
\end{Verbatim}


\subsection{A Worked Example}

TODO


\subsection{Further Examples}

The \href{https://github.com/downloads/dawsonjon/chips/Chips-0.1.tar.gz}{source distribution} contains a number of more involved examples so that
you can see for yourself how more complex hardware designs can be formed from
these simple components.

\resetcurrentobjects
\hypertarget{--doc-language\_reference/index}{}

\section{Chips Language Reference Manual}


\subsection{Chip}
\index{Chip (class in chips)}

\hypertarget{chips.Chip}{}\begin{classdesc}{Chip}{*args}
A Chip is device containing streams, sinks and processes.

Typically a Chip is used to describe a single device. You need to provide
the Chip object with a list of all the sinks (device outputs). You don't
need to include any process, variables or streams. By analysing the sinks,
the chip can work out which processes and streams need to be included in
the device.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips.VHDL\PYGZus{}plugin} \PYG{k+kn}{import} \PYG{n}{Plugin}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{switches} \PYG{o}{=} \PYG{n}{InPort}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{SWITCHES}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{serial\PYGZus{}in} \PYG{o}{=} \PYG{n}{SerialIn}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{RX}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{leds} \PYG{o}{=} \PYG{n}{OutPort}\PYG{p}{(}\PYG{n}{switches}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{LEDS}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{serial\PYGZus{}out} \PYG{o}{=} \PYG{n}{SerialOut}\PYG{p}{(}\PYG{n}{serial\PYGZus{}in}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{TX}\PYG{l+s}{"}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#We need to tell the Chip that leds and serial\PYGZus{}out are part of}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#the device. The Chip can work out for itself that switches and}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#serial\PYGZus{}in are part of the device.}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }   \PYG{n}{leds}\PYG{p}{,}
\PYG{g+gp}{... }   \PYG{n}{serial\PYGZus{}out}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{plugin} \PYG{o}{=} \PYG{n}{Plugin}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{s}\PYG{o}{.}\PYG{n}{write\PYGZus{}code}\PYG{p}{(}\PYG{n}{plugin}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}


\subsection{Process}
\index{chips.process (module)}
\hypertarget{module-chips.process}{}
\declaremodule[chips.process]{}{chips.process}
\modulesynopsis{}
\emph{Processes} are used to define the programs that will be executed in the target
\emph{Chip}.  Each \emph{Process} contains a single program made up of instructions. When
a \emph{Chip} is simulated, or run in real hardware, the program within each process
will be run concurrently.


\subsubsection{Process Inputs}

Any \emph{Stream} may be used as the input to a \emph{Process}. Only one process may read
from any particular stream.  A \emph{Process} may read from a \emph{Stream} using the
\emph{read} method. The \emph{read} method accepts a \emph{Variable} as its argument. A \emph{read}
from a \emph{Stream} will stall execution of the \emph{Process} until data is available.
Similarly, the stream will be stalled, until data is read from it. This
provides a handy way to synchronise processes together, and simplifies the
design of concurrent systems.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#sending process}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{theoutput} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#wait for 1 second}
\PYG{g+gp}{... }    \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} 
\PYG{g+gp}{... }        \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#send some data}
\PYG{g+gp}{... }    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+m+mi}{123}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#receiving process}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{target\PYGZus{}variable} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#This instruction will stall the process until data is available}
\PYG{g+gp}{... }    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{target\PYGZus{}variable}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#This instruction will not be run for 1 second}
\PYG{g+gp}{... }    \PYG{c}{\#..}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}
\end{Verbatim}


\subsubsection{Process Outputs}

An \emph{Output} is a special \emph{Stream} that can be written to by a \emph{Process}. Only one
\emph{Process} may write to any particular stream. Like any other \emph{Stream}, an
\emph{Output} may be:
\begin{itemize}
\item {} 
Read by a \emph{Process}.

\item {} 
Consumed by a \emph{Sink}.

\item {} 
Modified to form another \emph{Stream}.

\end{itemize}

A \emph{Process} may write to an \emph{Output} stream using the \emph{write} method. The
\emph{write} method accepts an expression as its argument. A \emph{write} to an output
will stall the process until the receiver is ready to receive data.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#sending process}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{theoutput} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#This instruction will stall the process until data is available}
\PYG{g+gp}{... }    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+m+mi}{123}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#This instruction will not be run for 1 second}
\PYG{g+gp}{... }    \PYG{c}{\#..}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#receiving process}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{target\PYGZus{}variable} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#wait for 1 second}
\PYG{g+gp}{... }    \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} 
\PYG{g+gp}{... }        \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{c}{\#get some data}
\PYG{g+gp}{... }    \PYG{n}{theoutput}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{target\PYGZus{}variable}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}
\end{Verbatim}


\subsubsection{Variables}

Data is stored and manipulated within a process using \emph{Variables}. A \emph{Variable}
may only be accessed by one process.  When a \emph{Variable} an initial value must
be supplied. A variable will be reset to its initial value before any process
instructions are executed.  A \emph{Variable} may be assigned a value using the
\emph{set} method. The \emph{set} method accepts an expression as its argument.

It is important to understand that a \emph{Variable} object created like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}
\end{Verbatim}

is different from a normal Python variable created like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{12}
\end{Verbatim}

The key is to understand that a \emph{Variable} will exist in the target \emph{Chip}, and
may be assigned and referenced as the \emph{Process} executes. A Python variable can
exist only in the Python environment, and not in a \emph{Chip}. While a Python
variable may be converted into a constant in the target \emph{Chip}, a \emph{Process}
has no way to change its value when it executes.


\subsubsection{Expressions}

\emph{Variables} and \emph{Constants} are the most basic form of expressions. More
complex expressions can be formed by combining \emph{Constants}, \emph{Variables} and
other expressions using following unary operators:

\begin{Verbatim}[commandchars=@\[\]]
@textasciitilde[]
\end{Verbatim}

and the folowing binary operators:

\begin{Verbatim}[commandchars=@\[\]]
+, -, *, //, @%, @&, @textbar[], @textasciicircum[], @textless[]@textless[], @textgreater[]@textgreater[], ==, !=, @textless[], @textless[]=, @textgreater[], @textgreater[]=
\end{Verbatim}

The function \emph{Not} evaluates to the logical negation of each data item
equivalent to \code{==0}. The function \emph{abs} evaluates to the magnitude of each
data item.

If one of the operands of a binary operator is not an expression, the Chips
library will attempt to convert this operand into an integer. If the conversion
is successful, a \emph{Constant} object will be created using the integer value.
The \emph{Constant} object will be used in place of the non-expression operand. This
allows constructs such as \code{a = 47+Constant(10)} to be used as a shorthand for
\code{a = Constant(47)+Constant(10)} or \code{count.set(Constant(15)+3*2} to be used
as a shorthand for \code{count.set(Constant(15)+Constant(6)}.  Of course \code{a=1+1}
still yields the integer 2 rather than an expression.

\begin{notice}{note}{Note:}
The divide \code{//} operator in \emph{Chips} works differently then the divide
operator in Python.  While a floor division in Python rounds to -infinite,
in \emph{Chips} division rounds to \code{0}. Thus \code{-3//2} rounds to \code{-2} in
Python, it rounds to \code{-1} in \emph{Chips}. This should be more familiar to
users of C, C++ and VHDL. The same also applies to the modulo \code{\%}
operator.
\end{notice}

An expression within a process will always inherit the data width in bits of
the \emph{Process} in which it is evaluated. A \emph{Stream} expression such as
\code{Repeater(255) + 1} will automatically yield a 10-bit \emph{Stream} so that the
value 256 can be represented. A similar expression Constant(255)+1 will give an
9-bit result in a 9-bit process yielding the value -1. If the same expression
is evaluated in a 10-bit process, the result will be 256.


\subsubsection{Operator Precedence}

The operator precedence is inherited from the Python language. The following
table summarizes the operator precedences, from lowest precedence (least
binding) to highest precedence (most binding). Operators in the same row have
the same precedence.

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operator
} & \textbf{
Description
}\\
\hline

==, !=, \textless{}, \textless{}=, \textgreater{}, \textgreater{}=
 & 
Comparisons
\\
{\raggedright{}~}
 & 
Bitwise OR
\\

\textasciicircum{}
 & 
Bitwise XOR
\\

\&
 & 
Bitwise AND
\\

\textless{}\textless{}, \textgreater{}\textgreater{}
 & 
Shifts
\\

+, -
 & 
Addition and subtraction
\\

*, //, \%
 & 
multiplication, division and modulo
\\

\textasciitilde{}
 & 
bitwise NOT
\\

Not, abs
 & 
logical NOT, absolute
\\
\hline
\end{tabulary}

\index{Process (class in chips)}

\hypertarget{chips.Process}{}\begin{classdesc}{Process}{bits, *instructions}\end{classdesc}
\index{Variable (class in chips)}

\hypertarget{chips.Variable}{}\begin{classdesc}{Variable}{initial}
A \emph{Variable} is used within a \emph{Process} to store data. A \emph{Variable} can
be used in only one \emph{Process}. If you need to communicate with another
\emph{Process} you must use a stream.

A \emph{Variable} accepts a single argument, the initial value. A \emph{Variable}
will be reset to the initial value when a simulation, or actual device is
reset.

A \emph{Variable} can be assigned an expression using the \emph{set} method.
\end{classdesc}
\index{VariableArray (class in chips)}

\hypertarget{chips.VariableArray}{}\begin{classdesc}{VariableArray}{size}
A \emph{VariableArray} is an array of variables that can be accessed from
within a single \emph{Process}.

When a \emph{VariableArray} is created, it accepts a single argument, the
\emph{size}.

A \emph{VariableArray} can be written to using the \emph{write} method, the \emph{write}
method accepts two arguments, an expression indicating the \emph{address} to
write to, and an expression indicating the \emph{data} to write.

A \emph{VariableArray} can be read to using the \emph{read} method, the \emph{read} method
accepts a single argument, an expression indicating the \emph{address} to read
from. The \emph{read method returns an expression that evaluates to the value
contained at *address}.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}items}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }     \PYG{l+s+sd}{"""Read number\PYGZus{}of\PYGZus{}items from stream, and reverse them."""}
\PYG{g+gp}{... }     \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }     \PYG{n}{index} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }     \PYG{n}{reversed\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }     \PYG{n}{data\PYGZus{}store} \PYG{o}{=} \PYG{n}{VariableArray}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}items}\PYG{p}{)}
\PYG{g+gp}{... }     \PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{index}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{While}\PYG{p}{(}\PYG{n}{index} \PYG{o}{\textless{}} \PYG{n}{number\PYGZus{}of\PYGZus{}items}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{n}{stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{n}{data\PYGZus{}store}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{n}{index}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{index}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}items} \PYG{o}{-} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{n}{While}\PYG{p}{(}\PYG{n}{index} \PYG{o}{\textgreater{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{n}{reversed\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{data\PYGZus{}store}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }             \PYG{n}{index}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{index}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }         \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }     \PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{... }     \PYG{k}{return} \PYG{n}{reversed\PYGZus{}stream}

\PYG{g+go}{    }
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{Sequence}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }     \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{3}
\PYG{g+go}{2}
\PYG{g+go}{1}
\PYG{g+go}{0}
\end{Verbatim}
\end{classdesc}


\subsection{Streams}
\index{chips.streams (module)}
\hypertarget{module-chips.streams}{}
\declaremodule[chips.streams]{}{chips.streams}
\modulesynopsis{}
Streams are a fundamental component of the \emph{Chips} library.
\begin{description}
\item[{A stream is used to represent a flow of data. A stream can act as a:}] \leavevmode\begin{itemize}
\item {} 
An input to a \emph{Chip} such as an \emph{InPort} or a \emph{SerialIn}.

\item {} 
A source of data in its own right such as a \emph{Repeater} or a \emph{Counter}.

\item {} 
A means of performing some operation on a stream of data to form 
another stream such as a \emph{Printer} or a \emph{Lookup}.

\item {} 
A means of transferring data from one process to another, an \emph{Output}.

\end{itemize}

\end{description}


\subsubsection{Stream Expressions}

A Stream Expression can be formed by combining Streams or Stream Expressions
with the following unary operators:

\begin{Verbatim}[commandchars=@\[\]]
@textasciitilde[]
\end{Verbatim}

and the folowing binary operators:

\begin{Verbatim}[commandchars=@\[\]]
+, -, *, //, @%, @&, @textbar[], @textasciicircum[], @textless[]@textless[], @textgreater[]@textgreater[], ==, !=, @textless[], @textless[]=, @textgreater[], @textgreater[]=
\end{Verbatim}

The function \emph{Not} yields the logical negation of each data item equivalent to
\code{==0}. The function \emph{abs} yields the magnitude of each data item.

Each data item in the resulting Stream Expression will be evaluated by removing
a data item from each of the operand streams, and applying the operator
function to these data items.

Generally speaking a Stream Expression will have enough bits to contain any
possible result without any arithmetic overflow. The one exception to this is
the left shift operator where the result is always truncated to the size of the
left hand operand. Stream expressions may be explicitly truncated or sign
extended using the \emph{Resizer}.

If one of the operands of a binary operator is not a Stream, Python Streams
will attempt to convert this operand into an integer. If the conversion is
successful, a \emph{Repeater} stream will be created using the integer value. The
repeater stream will be used in place of the non-stream operand. This allows
constructs such as \code{a = 47+InPort(12, 8)} to be used as a shorthand for \code{a =
Repeater(47)+InPort("in", 8)} or \code{count = Counter(1, 10, 1)+3*2} to be used as
a shorthand for \code{count = Counter(1, 10, 1)+Repeater(5)}.  Of course \code{a=1+1}
still yields the integer 2 rather than a stream.

\begin{notice}{note}{Note:}
The divide \code{//} operator in \emph{Chips} works differently then the divide
operator in Python.  While a floor division in Python rounds to -infinite,
in \emph{Chips} division rounds to \code{0}. Thus \code{-3//2} rounds to \code{-2} in
Python, it rounds to \code{-1} in \emph{Chips}. This should be more familiar to
users of C, C++ and VHDL. The same also applies to the modulo \code{\%}
operator.
\end{notice}

The operators provided in the Python Streams library are summarised in the
table below. The bit width field specifies how many bits are used for the
result based on the number of bits in the left and right hand operands.

\begin{tabulary}{\textwidth}{|L|L|L|}
\hline
\textbf{
Operator
} & \textbf{
Function
} & \textbf{
Data Width (bits)
}\\
\hline

abs
 & 
Logical Not
 & 
argument
\\

Not
 & 
Logical Not
 & 
1
\\

\textasciitilde{}
 & 
Bitwise not
 & 
right
\\

+
 & 
Signed Add
 & 
max(left, right) + 1
\\

-
 & 
Signed Subtract
 & 
max(left, right) + 1
\\

*
 & 
Signed Multiply
 & 
left + right
\\

//
 & 
Signed Floor Division
 & 
max(left, right) + 1
\\

\%
 & 
Signed Modulo
 & 
max(left, right)
\\

\&
 & 
Bitwise AND
 & 
max(left, right)
\\

\textbar{}
 & 
Bitwise OR
 & 
max(left, right)
\\

\textasciicircum{}
 & 
Bitwise XOR
 & 
max(left, right)
\\

\textless{}\textless{}
 & 
Arithmetic Left Shift
 & 
left
\\

\textgreater{}\textgreater{}
 & 
Arithmetic Right Shift
 & 
left
\\

==
 & 
Equality Comparison
 & 
1
\\

!=
 & 
Inequality Comparison
 & 
1
\\

\textless{}
 & 
Signed Less Than
Comparison
 & 
1
\\

\textless{}=
 & 
Signed Less Than or Equal
Comparison
 & 
1
\\

\textgreater{}
 & 
Signed Greater Than
Comparison
 & 
1
\\

\textgreater{}=
 & 
Signed Greater Than
Comparison
 & 
1
\\
\hline
\end{tabulary}



\subsubsection{Operator Precedence}

The operator precedence is inherited from the python language. The following
table summarizes the operator precedences, from lowest precedence (least
binding) to highest precedence (most binding). Operators in the same row have
the same precedence.

\begin{tabulary}{\textwidth}{|L|L|}
\hline
\textbf{
Operator
} & \textbf{
Description
}\\
\hline

==, !=, \textless{}, \textless{}=, \textgreater{}, \textgreater{}=
 & 
Comparisons
\\
{\raggedright{}~}
 & 
Bitwise OR
\\

\textasciicircum{}
 & 
Bitwise XOR
\\

\&
 & 
Bitwise AND
\\

\textless{}\textless{}, \textgreater{}\textgreater{}
 & 
Shifts
\\

+, -
 & 
Addition and subtraction
\\

*, //, \%
 & 
multiplication, division and modulo
\\

\textasciitilde{}
 & 
bitwise NOT
\\

Not, abs
 & 
logical NOT, absolute
\\
\hline
\end{tabulary}



\subsubsection{Streams Reference}
\index{Array (class in chips)}

\hypertarget{chips.Array}{}\begin{classdesc}{Array}{address\_in, data\_in, address\_out, depth}
An \emph{Array} is a stream yields values from a writeable lookup table.

Like a \emph{Lookup}, an \emph{Array} looks up each data item in the \emph{address\_in}
stream, and yields the value in the lookup table. In an \emph{Array}, the lookup
table is set up dynamically using data items from the \emph{address\_in} and
\emph{data\_in} streams. An \emph{Array} is equivalent to a Random Access Memory (RAM)
with independent read, and write ports.

A \emph{Lookup} accepts \emph{address\_in}, \emph{data\_in} and \emph{address\_out} arguments as
source streams. The \emph{depth} argument specifies the size of the lookup table.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{video\PYGZus{}raster\PYGZus{}stream}\PYG{p}{(}\PYG{n}{width}\PYG{p}{,} \PYG{n}{height}\PYG{p}{,} \PYG{n}{row\PYGZus{}stream}\PYG{p}{,} \PYG{n}{col\PYGZus{}stream}\PYG{p}{,} 
\PYG{g+gp}{... }                        \PYG{n}{intensity}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }
\PYG{g+gp}{... }    \PYG{n}{pixel\PYGZus{}clock} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{width}\PYG{o}{*}\PYG{n}{height}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{... }     
\PYG{g+gp}{... }    \PYG{n}{pixstream} \PYG{o}{=} \PYG{n}{Array}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{address\PYGZus{}in} \PYG{o}{=} \PYG{p}{(}\PYG{n}{row\PYGZus{}stream} \PYG{o}{*} \PYG{n}{width}\PYG{p}{)} \PYG{o}{+} \PYG{n}{col\PYGZus{}stream}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{data\PYGZus{}in} \PYG{o}{=} \PYG{n}{intensity}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{address\PYGZus{}out} \PYG{o}{=} \PYG{n}{pixel\PYGZus{}clock}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{depth} \PYG{o}{=} \PYG{n}{width} \PYG{o}{*} \PYG{n}{height}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{pixstream}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{pixstream} \PYG{o}{=} \PYG{n}{video\PYGZus{}raster\PYGZus{}stream}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{l+m+mi}{64}\PYG{p}{,} 
\PYG{g+gp}{... }    \PYG{l+m+mi}{64}\PYG{p}{,} 
\PYG{g+gp}{... }    \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{,} 
\PYG{g+gp}{... }    \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} 
\PYG{g+gp}{... }    \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Counter (class in chips)}

\hypertarget{chips.Counter}{}\begin{classdesc}{Counter}{start, stop, step}
A Stream which yields numbers from \emph{start} to \emph{stop} in \emph{step} increments.

A \emph{Counter} is a versatile, and commonly used construct in device design,
they can be used to number samples, index memories and so on.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c}{\#creates a 4 bit stream}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{2}
\PYG{g+go}{4}
\PYG{g+go}{6}
\PYG{g+go}{8}
\PYG{g+go}{10}
\PYG{g+go}{0}
\PYG{g+gp}{...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{-}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c}{\#creates a 4 bit stream}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+go}{8}
\PYG{g+go}{6}
\PYG{g+go}{4}
\PYG{g+go}{2}
\PYG{g+go}{0}
\PYG{g+go}{10}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{Decoupler (class in chips)}

\hypertarget{chips.Decoupler}{}\begin{classdesc}{Decoupler}{source}
A \emph{Decoupler} removes stream handshaking.

Usually, data is transfered though streams using blocking transfers. When a
process writes to a stream, execution will be halted until the receiving
process reads the data. While this behaviour greatly simplifies the design
of parallel processes, sometimes Non-blocking transfers are needed. When a
data item is written to a \emph{Decoupler}, it is stored. When a \emph{Decoupler} is
read from, the value of the last stored value is yielded. Neither the
sending or the receiving process ever blocks. This also means that the
number of data items written into the \emph{Decoupler} and the number read out
do not have to be the same.

A \emph{Decoupler} accepts only one argument, the source stream.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{time\PYGZus{}stamp\PYGZus{}data}\PYG{p}{(}\PYG{n}{data\PYGZus{}stream}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }
\PYG{g+gp}{... }    \PYG{n}{us\PYGZus{}time} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{time} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{time}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{time} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{us\PYGZus{}time}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{time}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{... }    \PYG{n}{output\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{data\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{output\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{us\PYGZus{}time}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{output\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{output\PYGZus{}stream}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{time\PYGZus{}stamped\PYGZus{}stream} \PYG{o}{=} \PYG{n}{time\PYGZus{}stamp\PYGZus{}data}\PYG{p}{(}\PYG{n}{SerialIn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Fifo (class in chips)}

\hypertarget{chips.Fifo}{}\begin{classdesc}{Fifo}{data\_in, depth}
A \emph{Fifo} stores a buffer of data items.

A \emph{Fifo} contains a fixed size buffer of objects obtained from the source
stream. A \emph{Fifo} yields the data items in the same order in which they were
stored.

The first argument to a \emph{Fifo}, is the source stream, the \emph{depth} argument
determines the size of the Fifo buffer.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{scope}\PYG{p}{(}\PYG{n}{ADC\PYGZus{}stream}\PYG{p}{,} \PYG{n}{trigger\PYGZus{}level}\PYG{p}{,} \PYG{n}{buffer\PYGZus{}depth}\PYG{p}{)}\PYG{p}{:} 
\PYG{g+gp}{... }    \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n+nb}{buffer} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }
\PYG{g+gp}{... }    \PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{ADC\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{If}\PYG{p}{(}\PYG{n}{temp} \PYG{o}{\textgreater{}} \PYG{n}{trigger\PYGZus{}level}\PYG{p}{,}
\PYG{g+gp}{... }                \PYG{n+nb}{buffer}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{buffer\PYGZus{}depth} \PYG{o}{-} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,}
\PYG{g+gp}{... }                    \PYG{n}{ADC\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                    \PYG{n+nb}{buffer}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                    \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }                \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }            
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{Fifo}\PYG{p}{(}\PYG{n+nb}{buffer}\PYG{p}{,} \PYG{n}{buffer\PYGZus{}depth}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{test\PYGZus{}signal} \PYG{o}{=} \PYG{n}{Sequence}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{scope}\PYG{p}{(}\PYG{n}{test\PYGZus{}signal}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{4}
\PYG{g+go}{5}
\end{Verbatim}
\end{classdesc}
\index{HexPrinter (class in chips)}

\hypertarget{chips.HexPrinter}{}\begin{classdesc}{HexPrinter}{source}
A \emph{HexPrinter} turns data into hexadecimal ASCII characters.

Each each data item is turned into the ASCII representation of its
hexadecimal value, terminated with a newline character. Each character then
forms a data item in the \emph{HexPrinter} stream.

A \emph{HexPrinter} accepts a single argument, the source stream. A \emph{HexPrinter}
stream is always 8 bits wide.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#print the numbers 0x0-0x10 to the console repeatedly}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{HexPrinter}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mh}{0x0}\PYG{p}{,} \PYG{l+m+mh}{0x10}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{4}
\PYG{g+go}{5}
\PYG{g+go}{6}
\PYG{g+go}{7}
\PYG{g+go}{8}
\PYG{g+go}{9}
\PYG{g+go}{a}
\PYG{g+go}{b}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{InPort (class in chips)}

\hypertarget{chips.InPort}{}\begin{classdesc}{InPort}{name, bits}
A device input port stream.

An \emph{InPort} allows a port pins of the target device to be used as a data
stream.  There is no handshaking on the input port. The port pins are
sampled at the point when data is transfered by the stream.  When
implemented in VHDL, the \emph{InPort} provides double registers on the port
pins to synchronise data to the local clock domain.

Since it is not possible to determine the width of the stream in bits
automatically, this must be specified using the \emph{bits} argument.

The \emph{name} parameter allows a string to be associated with the input port.
In a VHDL implementation, \emph{name} will be used as the port name in the
top level entity.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dip\PYGZus{}switches} \PYG{o}{=} \PYG{n}{InPort}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{dip\PYGZus{}switches}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)} 
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{SerialOut}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{dip\PYGZus{}switches}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Lookup (class in chips)}

\hypertarget{chips.Lookup}{}\begin{classdesc}{Lookup}{source, *args}
A \emph{Lookup} is a stream yields values from a read-only look up table.

For each data item in the source stream, a \emph{Lookup} will yield the
addressed value in the lookup table. A \emph{Lookup} is basically a Read Only
Memory(ROM) with the source stream forming the address, and the \emph{Lookup}
itself forming the data output.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{binary\PYGZus{}2\PYGZus{}gray}\PYG{p}{(}\PYG{n}{input\PYGZus{}stream}\PYG{p}{)}\PYG{p}{:} 
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{Lookup}\PYG{p}{(}\PYG{n}{input\PYGZus{}stream}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{binary\PYGZus{}2\PYGZus{}gray}\PYG{p}{(}\PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{3}
\PYG{g+go}{2}
\PYG{g+go}{6}
\PYG{g+go}{7}
\PYG{g+go}{5}
\PYG{g+go}{4}
\PYG{g+go}{0}
\PYG{g+gp}{...}
\end{Verbatim}

The first argument to a \emph{Lookup} is the source stream, all additional
arguments form the lookup table. If you want to use a Python sequence
object such as a tuple or a list to form the lookup table use the following
syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]} 
\PYG{g+gp}{... }\PYG{n}{my\PYGZus{}sequence} \PYG{o}{=} \PYG{n}{Lookup}\PYG{p}{(}\PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{o}{*}\PYG{n}{my\PYGZus{}list}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Output (class in chips)}

\hypertarget{chips.Output}{}\begin{classdesc}{Output}{}
An \emph{Output} is a stream that can be written to by a process.

Any stream can be read from by a process. Only an \emph{Output} stream can be
written to by a process.  A process can be written to by using the \emph{read}
method. The read method accepts one argument, an expression to write.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{tee}\PYG{p}{(}\PYG{n}{input\PYGZus{}stream}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{output\PYGZus{}stream\PYGZus{}1} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{output\PYGZus{}stream\PYGZus{}2} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{n}{Process}\PYG{p}{(}\PYG{n}{input\PYGZus{}stream}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{input\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{output\PYGZus{}stream\PYGZus{}1}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{output\PYGZus{}stream\PYGZus{}2}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{output\PYGZus{}stream\PYGZus{}1}\PYG{p}{,} \PYG{n}{output\PYGZus{}stream\PYGZus{}2}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{os\PYGZus{}1}\PYG{p}{,} \PYG{n}{os\PYGZus{}2} \PYG{o}{=} \PYG{n}{tee}\PYG{p}{(}\PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{os\PYGZus{}1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{os\PYGZus{}2}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{3}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{Printer (class in chips)}

\hypertarget{chips.Printer}{}\begin{classdesc}{Printer}{source}
A \emph{Printer} turns data into decimal ASCII characters.

Each each data item is turned into the ASCII representation of its decimal
value, terminated with a newline character. Each character then forms a
data item in the \emph{Printer} stream.

A \emph{Printer} accepts a single argument, the source stream. A \emph{Printer}
stream is always 8 bits wide.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#print the numbers 0-10 to the console repeatedly}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }   \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+go}{3}
\PYG{g+go}{4}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{Repeater (class in chips)}

\hypertarget{chips.Repeater}{}\begin{classdesc}{Repeater}{value}
A stream which repeatedly yields the specified \emph{value}.

The \emph{Repeater} stream is one of the most fundamental streams available.

The width of the stream in bits is calculated automatically. The smallest
number of bits that can represent \emph{value} in twos-complement format will be
used.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c}{\#creates a 4 bit stream}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{5}
\PYG{g+go}{5}
\PYG{g+go}{5}
\PYG{g+gp}{...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c}{\#creates a 5 bit stream}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+go}{10}
\PYG{g+go}{10}
\PYG{g+gp}{...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{=}\PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{c}{\#This is shorthand for: Repeater(5)*Repeater(2)}
\PYG{g+gp}{... }            \PYG{n}{Repeater}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+go}{10}
\PYG{g+go}{10}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{Resizer (class in chips)}

\hypertarget{chips.Resizer}{}\begin{classdesc}{Resizer}{source, bits}
A \emph{Resizer} changes the width, in bits, of the source stream.

The \emph{Resizer} takes two arguments, the source stream, and the \emph{width} in
bits. The \emph{Resizer} will truncate data if it is reducing the width, ans
sign extend if it is increasing the width.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{InPort}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{din}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{bits}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{c}{\#a has a width of 8 bits}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{c}{\#b has a width of 9 bits}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{9}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Resizer}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)} \PYG{c}{\#c is truncated to 8 bits}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{get\PYGZus{}bits}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Chip}\PYG{p}{(}\PYG{n}{OutPort}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{dout}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{Chip(...}
\end{Verbatim}
\end{classdesc}
\index{Scanner() (in module chips)}

\hypertarget{chips.Scanner}{}\begin{funcdesc}{Scanner}{stream, bits}
A \emph{Scanner} converts a stream of decimal ASCII into their integer value.

Numeric characters separated by non-numeric characters are interpreted as
numbers.  As it is not possible to determine the maximum value of a
\emph{Scanner} stream at compile time, the width of the stream must be specified
using the bits parameter.

The \emph{Scanner} stream accepts two inputs, the source stream and the number
of bits.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#multiply by two and echo}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Scanner}\PYG{p}{(}\PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{10 20 30 }\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{c}{\# doctest: +ELLIPSIS}
\PYG{g+go}{20}
\PYG{g+go}{40}
\PYG{g+go}{60}
\PYG{g+go}{20}
\PYG{g+gp}{...}
\end{Verbatim}
\end{funcdesc}
\index{Sequence() (in module chips)}

\hypertarget{chips.Sequence}{}\begin{funcdesc}{Sequence}{*args}
A \emph{Sequence} stream yields each of its arguments in turn repeatedly.

A \emph{Sequence} accepts any number of arguments. The bit width of a sequence
is determined automatically, using the number of bits necessary to
represent the argument with the largest magnitude. A \emph{Sequence} allows
Python sequences to be used within a Chips simulation using the
\code{Sequence(*python\_sequence)} syntax.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{g+go}{hello world}
\PYG{g+go}{hello world}
\PYG{g+go}{hello world}
\PYG{g+gp}{...}
\end{Verbatim}
\end{funcdesc}
\index{SerialIn (class in chips)}

\hypertarget{chips.SerialIn}{}\begin{classdesc}{SerialIn}{name='RX', clock\_rate=50000000, baud\_rate=115200}
A \emph{SerialIn} yields data from a serial UART port.

\emph{SerialIn} yields one data item from the serial input port for each
character read from the source stream.  The stream is always 8 bits wide.

A \emph{SerialIn} accepts an optional \emph{name} argument which is used as the name
for the serial RX line in generated VHDL. The clock rate of the target
device in MHz can be specified using the \emph{clock\_rate} argument. The baud
rate of the serial input can be specified using the \emph{baud\_rate} argument.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#echo typed characters}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{SerialOut}\PYG{p}{(}\PYG{n}{SerialIn}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Stimulus (class in chips)}

\hypertarget{chips.Stimulus}{}\begin{classdesc}{Stimulus}{bits}
A Stream that allows a Python iterable to be used as a stream.

A Stimulus stream allows a transparent method to pass data from the Python
environment into the simulation environment. The sequence object is set at
run time using the set\_simulation\_data() method. The sequence object can be
any iterable Python sequence such as a list, tuple, or even a generator.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{stimulus} \PYG{o}{=} \PYG{n}{Stimulus}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{stimulus}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{g+gp}{... }    \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{k}{yield} \PYG{n}{i}
\PYG{g+gp}{... }        \PYG{n}{i}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{g+gp}{... }

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{stimulus}\PYG{o}{.}\PYG{n}{set\PYGZus{}simulation\PYGZus{}data}\PYG{p}{(}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{1}
\PYG{g+go}{2}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}


\subsection{Sinks}
\index{chips.sinks (module)}
\hypertarget{module-chips.sinks}{}
\declaremodule[chips.sinks]{}{chips.sinks}
\modulesynopsis{}
Sinks are a fundamental component of the \emph{Chips} library.
\begin{description}
\item[{A sink is used to terminate a stream. A sink may act as:}] \leavevmode\begin{itemize}
\item {} 
An output of a \emph{Chip} such as an \emph{OutPort} or \emph{SerialOut}.

\item {} 
A consumer of data in its own right such as an \emph{Asserter}.

\end{itemize}

\end{description}


\subsubsection{Sinks Reference}
\index{Asserter (class in chips)}

\hypertarget{chips.Asserter}{}\begin{classdesc}{Asserter}{a}
An \emph{Asserter} causes an exception if any data in the source stream is zero.

An \emph{Asserter} is particularly useful in automated tests, as it causes a
simulation to fail is a condition is not met. In generated VHDL code, an
asserter is represented by a VHDL assert statement. In practice this means
that an \emph{Asserter} will function correctly in a VHDL simulation, but will
have no effect when synthesized.

The \emph{Asserter} sink accepts a source stream argument, \emph{a}.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Sequence}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Asserter}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{n}{Sequence}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Look at the Chips test suite for more examples of the Asserter being used
for automated testing.
\end{classdesc}
\index{Console (class in chips)}

\hypertarget{chips.Console}{}\begin{classdesc}{Console}{a}
A \emph{Console} outputs data to the simulation console.

\emph{Console} stores characters for output to the console in a buffer. When an
end of line character is seen, the buffer is written to the console.  A
\emph{Console} interprets a stream of numbers as ASCII characters. The source
stream must be 8 bits wide. The source stream could be truncated to 8 bits
using a \emph{Resizer}, but it is usually more convenient to use a \emph{Printer} as
the source stream. The will allow a stream of any width to be represented
as a decimal string.

A \emph{Console} accepts a source stream argument \emph{a}.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#convert string into a sequence of characters}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{hello\PYGZus{}world} \PYG{o}{=} \PYG{n+nb}{tuple}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n}{hello\PYGZus{}world}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{OutPort (class in chips)}

\hypertarget{chips.OutPort}{}\begin{classdesc}{OutPort}{a, name}
An \emph{OutPort} sink outputs a stream of data to I/O port pins.

No handshaking is performed on the output port, data will appear at the
time when the source stream transfers data.

An output port take two arguments, the source stream \emph{a} and a string
\emph{name}. Name is used as the port name in generated VHDL.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{dip\PYGZus{}switches} \PYG{o}{=} \PYG{n}{InPort}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{dip\PYGZus{}switches}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)} 
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{led\PYGZus{}array} \PYG{o}{=} \PYG{n}{OutPort}\PYG{p}{(}\PYG{n}{dip\PYGZus{}switches}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{led\PYGZus{}array}\PYG{l+s}{"}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{s} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{led\PYGZus{}array}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Response (class in chips)}

\hypertarget{chips.Response}{}\begin{classdesc}{Response}{a}
A \emph{Response} sink allows data to be transfered into Python.

As a simulation is run, the \emph{Response} sink accumulates data. After a
simulation is run, you can retrieve a python iterable using the
get\_simulation\_data method. Using a \emph{Response} sink allows you to
seamlessly integrate your \emph{Chips} simulation into a wider Python
simulation. This works for simulations using an external simulator as well,
in this case you also need to pass the code generation plugin to
get\_simulation\_data.

A \emph{Response} sink accepts a single stream argument as its source.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{streams} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{import} \PYG{n+nn}{PIL.Image} \PYG{c}{\#You need the Python Imaging Library for this}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{image\PYGZus{}processor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }   \PYG{c}{\#black -\textgreater{} white}
\PYG{g+gp}{... }   \PYG{k}{return} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{63}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{4}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{response} \PYG{o}{=} \PYG{n}{Response}\PYG{p}{(}\PYG{n}{image\PYGZus{}processor}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{response}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{chip}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{chip}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100000}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{image\PYGZus{}data} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{response}\PYG{o}{.}\PYG{n}{get\PYGZus{}simulation\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{image\PYGZus{}data} \PYG{o}{=} \PYG{n}{image\PYGZus{}data}\PYG{p}{[}\PYG{p}{:}\PYG{p}{(}\PYG{l+m+mi}{64}\PYG{o}{*}\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{im} \PYG{o}{=} \PYG{n}{PIL}\PYG{o}{.}\PYG{n}{Image}\PYG{o}{.}\PYG{n}{new}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{L}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{putdata}\PYG{p}{(}\PYG{n}{image\PYGZus{}data}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{im}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{SerialOut (class in chips)}

\hypertarget{chips.SerialOut}{}\begin{classdesc}{SerialOut}{a, name='TX', clock\_rate=50000000, baud\_rate=115200}
A \emph{SerialOut} outputs data to a serial UART port.

\emph{SerialOut} outputs one character to the serial output port for each item
of data in the source stream. At present only 8 data bits are supported, so
the source stream must be 8 bits wide. The source stream could be truncated
to 8 bits using a \emph{Resizer}, but it is usually more convenient to use a
\emph{Printer} as the source stream. The will allow a stream of any width to be
represented as a decimal string.

A SerialOut accepts a source stream argument \emph{a}. An optional \emph{name}
argument is used as the name for the serial TX line in generated VHDL. The
clock rate of the target device in MHz can be specified using the
\emph{clock\_rate} argument. The baud rate of the serial output can be specified
using the \emph{baud\_rate} argument.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#convert string into a sequence of characters}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{hello\PYGZus{}world} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{hello world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{my\PYGZus{}chip} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{SerialOut}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n}{hello\PYGZus{}world}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}
\end{Verbatim}
\end{classdesc}


\subsection{Instructions}
\index{chips.instruction (module)}
\hypertarget{module-chips.instruction}{}
\declaremodule[chips.instruction]{}{chips.instruction}
\modulesynopsis{}
The instructions provided here form the basis of the software that can be run inside \emph{Processes}.


\subsubsection{Instructions Reference}
\index{Block (class in chips)}

\hypertarget{chips.Block}{}\begin{classdesc}{Block}{instructions}
The \emph{Block} statement allows instructions to be nested into a single
statement. Using a \emph{Block} allows a group of instructions to be stored as a
single object. A block accepts a single argument, \emph{instructions}, a Python
Sequence of instructions

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{initialise} \PYG{o}{=} \PYG{n}{Block}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{initialise}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{a}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{b}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}
\end{Verbatim}
\end{classdesc}
\index{Break (class in chips)}

\hypertarget{chips.Break}{}\begin{classdesc}{Break}{}
The \emph{Break} statement causes the flow of control to immediately exit the loop.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#equivalent to a While loop}
\PYG{n}{Loop}\PYG{p}{(}
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{Not}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{c}{\#do stuff here}
\PYG{p}{)}\PYG{p}{,}
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#equivalent to a DoWhile loop}
\PYG{n}{Loop}\PYG{p}{(}
    \PYG{c}{\#do stuff here}
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{Not}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}\PYG{p}{,}
\end{Verbatim}
\end{classdesc}
\index{Continue (class in chips)}

\hypertarget{chips.Continue}{}\begin{classdesc}{Continue}{}
The \emph{Continue} statement causes the flow of control to immediately jump to
the next iteration of the containing loop.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{in\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{out\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#allow only even numbers}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{in\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{If}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\&}\PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{Continue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{out\PYGZus{}stream}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+go}{2}
\PYG{g+go}{4}
\PYG{g+go}{6}
\PYG{g+go}{8}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{DoUntil() (in module chips)}

\hypertarget{chips.DoUntil}{}\begin{funcdesc}{DoUntil}{condition, *instructions}
A loop in which one iteration will be executed each time the condition
is false. The condition is tested after each loop iteration.

Equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Loop}\PYG{p}{(} 
     \PYG{n}{instructions}\PYG{p}{,}
     \PYG{n}{If}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,} \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{)}
\end{Verbatim}
\end{funcdesc}
\index{DoWhile() (in module chips)}

\hypertarget{chips.DoWhile}{}\begin{funcdesc}{DoWhile}{condition, *instructions}
A loop in which one iteration will be executed each time the condition
is true. The condition is tested after each loop iteration.

Equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Loop}\PYG{p}{(} 
     \PYG{n}{instructions}\PYG{p}{,}
     \PYG{n}{If}\PYG{p}{(}\PYG{n}{Not}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
 \PYG{p}{)}
\end{Verbatim}
\end{funcdesc}
\index{Evaluate (class in chips)}

\hypertarget{chips.Evaluate}{}\begin{classdesc}{Evaluate}{*instructions}\end{classdesc}
\index{If (class in chips)}

\hypertarget{chips.If}{}\begin{classdesc}{If}{condition, *instructions}
The \emph{If} statement conditionally executes instructions.

The condition of the \emph{If} branch is evaluated, followed by the condition of
each of the optional \emph{Elif} branches. If one of the conditions evaluates
to non-zero then the corresponding instructions will be executed. If the
\emph{If} condition, and all of the \emph{Elif} conditions evaluate to zero, then
the instructions in the optional \emph{Else} branch will be evaluated.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{If}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,}
    \PYG{c}{\#do something}
\PYG{p}{)}\PYG{o}{.}\PYG{n}{Elif}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,}
    \PYG{c}{\#do something else}
\PYG{p}{)}\PYG{o}{.}\PYG{n}{Else}\PYG{p}{(}
    \PYG{c}{\#if all else fails do this}
\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{Loop (class in chips)}

\hypertarget{chips.Loop}{}\begin{classdesc}{Loop}{*instructions}
The \emph{Loop} statement executes instructions repeatedly.

A \emph{Loop} can be exited using the \emph{Break} instruction. A \emph{Continue}
instruction causes the remainder of instructions in the loop to be skipped.
Execution then repeats from the beginning of the \emph{Loop}.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#filter values over 50 out of a stream}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{in\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Sequence}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{90}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{out\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{in\PYGZus{}stream}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{If}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\textgreater{}} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{Continue}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{Console}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Printer}\PYG{p}{(}\PYG{n}{out\PYGZus{}stream}\PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+go}{10}
\PYG{g+go}{20}
\PYG{g+go}{30}
\PYG{g+go}{40}
\PYG{g+go}{50}
\PYG{g+go}{10}
\PYG{g+gp}{...}
\end{Verbatim}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#initialise an array}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{myarray} \PYG{o}{=} \PYG{n}{VariableArray}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{index} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }    \PYG{n}{If}\PYG{p}{(}\PYG{n}{index} \PYG{o}{==} \PYG{l+m+mi}{100}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{myarray}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Loop(...}
\end{Verbatim}
\end{classdesc}
\index{Print (class in chips)}

\hypertarget{chips.Print}{}\begin{classdesc}{Print}{stream, exp, minimum\_number\_of\_digits=None}
The \emph{Print} instruction write an integer to a stream in decimal ASCII
format.

Print will not add any white space or line ends (in contrast to the
\emph{Printer}) The \emph{Print} instruction accepts two arguments, the destination
\emph{stream}, which must be an \emph{Output} stream, and a numeric expression,
\emph{exp}. An optional third argument specifies the minimum number of digits to
print (leading 0 characters are added).

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#multiply by 2 and echo}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{inp} \PYG{o}{=} \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{1 2 3 }\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{out\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p}\PYG{o}{=}\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Scan}\PYG{p}{(}\PYG{n}{inp}\PYG{p}{,} \PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{out\PYGZus{}stream}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+go}{4}
\PYG{g+go}{6}
\PYG{g+go}{2}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{Scan (class in chips)}

\hypertarget{chips.Scan}{}\begin{classdesc}{Scan}{stream, variable}
The \emph{Scan} instruction reads an integer value from a stream of decimal
ASCII characters.

Numeric characters separated by non-numeric characters are interpreted as
numbers. If \emph{Scan} encounters a number that is too large to represent in a
process, the result is undefined.

The \emph{Scan} accepts two arguments, the source stream and a destination variable.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#multiply by 2 and echo}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{temp} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{inp} \PYG{o}{=} \PYG{n}{Sequence}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{1 2 3 }\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{out} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{p}\PYG{o}{=}\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{Scan}\PYG{p}{(}\PYG{n}{inp}\PYG{p}{,} \PYG{n}{temp}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{out}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{temp}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{(}\PYG{n}{Printer}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{c}{\# doctest: +ELLIPSIS}
\PYG{g+go}{2}
\PYG{g+go}{4}
\PYG{g+go}{6}
\PYG{g+gp}{...}
\end{Verbatim}
\end{classdesc}
\index{Until() (in module chips)}

\hypertarget{chips.Until}{}\begin{funcdesc}{Until}{condition, *instructions}
A loop in which one iteration will be executed each time the condition
is false. The condition is tested before each loop iteration.

Equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Loop}\PYG{p}{(} 
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{,} \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{instructions}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}
\end{funcdesc}
\index{Value (class in chips)}

\hypertarget{chips.Value}{}\begin{classdesc}{Value}{expression}
The \emph{Value} statement gives a value to the surrounding \emph{Evaluate}
construct.

An \emph{Evaluate}  expression allows a block of statements to be used as an
expression. When a \emph{Value} is encountered, the supplied expression becomes
the value of the whole evaluate statement.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{c}{\#provide a And expression similar to Pythons and expression}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k}{def} \PYG{n+nf}{LogicalAnd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{return} \PYG{n}{Evaluate}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{If}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{Value}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{o}{.}\PYG{n}{Else}\PYG{p}{(}
\PYG{g+gp}{... }            \PYG{n}{Value}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}
\PYG{g+gp}{... }    \PYG{p}{)}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{check} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{If}\PYG{p}{(}\PYG{n}{LogicalAnd}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{check}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{c}{\#true}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{o}{.}\PYG{n}{Else}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{check}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{c}{\#false}
\PYG{g+gp}{... }    \PYG{p}{)}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c} \PYG{o}{=} \PYG{n}{Chip}\PYG{p}{(}\PYG{n}{Asserter}\PYG{p}{(}\PYG{n}{check}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{c}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{Verbatim}
\end{classdesc}
\index{WaitUs (class in chips)}

\hypertarget{chips.WaitUs}{}\begin{classdesc}{WaitUs}{}
\emph{WaitUs} causes execution to halt until the next tick of the microsecond
timer.

In practice, this means that the process is stalled for less than 1
microsecond. This behaviour is useful when implementing a real-time
counter function because the execution time of statements does not affect
the time between \emph{WaitUs} statements (Providing the statements do not take
more than 1 microsecond to execute of course!).

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{k+kn}{from} \PYG{n+nn}{chips} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{seconds} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{count} \PYG{o}{=} \PYG{n}{Variable}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{out\PYGZus{}stream} \PYG{o}{=} \PYG{n}{Output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\textgreater{}\textgreater{}\textgreater{} }\PYG{n}{Process}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{seconds}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{n}{Loop}\PYG{p}{(}
\PYG{g+gp}{... }        \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{While}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{WaitUs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }            \PYG{n}{count}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{count}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{seconds}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{seconds} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }        \PYG{n}{out\PYGZus{}stream}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{seconds}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }    \PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{... }\PYG{p}{)}
\PYG{g+go}{Process(...}
\end{Verbatim}
\end{classdesc}
\index{While() (in module chips)}

\hypertarget{chips.While}{}\begin{funcdesc}{While}{condition, *instructions}
A loop in which one iteration will be executed each time the condition
is true. The condition is tested before each loop iteration.

Equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Loop}\PYG{p}{(} 
    \PYG{n}{If}\PYG{p}{(}\PYG{n}{Not}\PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Break}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{instructions}\PYG{p}{,}
\PYG{p}{)}
\end{Verbatim}
\end{funcdesc}

\resetcurrentobjects
\hypertarget{--doc-automatic\_code\_generation/index}{}

\section{Automatic Code Generation}


\subsection{VHDL Code Generation}
\index{chips.VHDL\_plugin (module)}
\hypertarget{module-chips.VHDL\_plugin}{}
\declaremodule[chips.VHDLplugin]{}{chips.VHDL\_plugin}
\modulesynopsis{}
VHDL Code Generation for streams library


\subsection{C++ Code Generation}
\index{chips.cpp\_plugin (module)}
\hypertarget{module-chips.cpp\_plugin}{}
\declaremodule[chips.cppplugin]{}{chips.cpp\_plugin}
\modulesynopsis{}
C++ code generator for streams library


\subsection{Visualisation Code Generation}
\index{chips.visual\_plugin (module)}
\hypertarget{module-chips.visual\_plugin}{}
\declaremodule[chips.visualplugin]{}{chips.visual\_plugin}
\modulesynopsis{}
Visualisation for streams library

\resetcurrentobjects
\hypertarget{--doc-ip\_library/index}{}

\section{IP library}
\index{chips.ip (module)}
\hypertarget{module-chips.ip}{}
\declaremodule[chips.ip]{}{chips.ip}
\modulesynopsis{}
\resetcurrentobjects
\hypertarget{--doc-extending\_chips/index}{}

\section{Extending the Chips Library}


\chapter{News}
\begin{itemize}
\item {} 
2011-04-09 Chips Library Published on GitHub.

\item {} 
2011-04-29 Chips Library Published on Python Package Index.

\end{itemize}


\chapter{Links}
\begin{itemize}
\item {} 
\href{http://scipy.org}{SciPy} Scientific Tools for Python.

\item {} 
\href{http://matplotlib.sourceforge.net}{matplotlib} 2D plotting library for Python.

\item {} 
\href{http://www.pythonware.com/products/pil/}{Python Imaging Library (PIL)} Python Imaging Library adds image processing
capabilities to Python.

\item {} 
\href{http://www.myhdl.org}{MyHDL} A Hardware description language based on Python.

\end{itemize}


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\item {} 
\emph{Search Page}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
