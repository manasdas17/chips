"""VHDL generation of the Array Primitive"""

import common

__author__ = "Jon Dawson"
__copyright__ = "Copyright 2010, Jonathan P Dawson"
__license__ = "MIT"
__version__ = "0.1.3"
__maintainer__ = "Jon Dawson"
__email__ = "chips@jondawson.org.uk"
__status__ = "Prototype"

def write(plugin, stream):

    identifier = stream.get_identifier()
    bits = stream.get_bits()
    depth = stream.depth
    identifier_a = stream.a.get_identifier()
    identifier_b = stream.b.get_identifier()
    identifier_c = stream.c.get_identifier()
    if hasattr(plugin, "has_array"):
        one_offs = False
    else:
        plugin.has_array=True
        one_offs = True

    dependencies = [
"",
"--  ****************************************************************************",
"--  Filename         :",
"--  Project          :",
"--  Version          :0.1",
"--  Author           :Jonathan P Dawson",
"--  Created Date     :2005-12-18",
"--  ****************************************************************************",
"--  Description      :A RAM based on Xilinx block RAMs",
"--  ****************************************************************************",
"--  Dependencies     :Standard Libraries",
"--  ****************************************************************************",
"--  Revision History :",
"--  ",
"--  Date :2005-12-18",
"--  Author :Jonathan P Dawson",
"--  Modification: Created File",
"--  ",
"--  ****************************************************************************",
"--  Copyright (C) Jonathan P Dawson 2005",
"--  ****************************************************************************",
" library ieee;",
" use ieee.std_logic_1164.all;",
" use ieee.numeric_std.all;",
"",
" entity RAMARRAY is",
"    generic(",
"        DEPTH : integer;",
"        WIDTH : integer",
"    );",
"    port(",
"        CLK             : in  std_logic;",
"        RST             : in  std_logic;",
"        ADDRESS_IN      : in  std_logic_vector;",
"        ADDRESS_IN_STB  : in  std_logic;",
"        ADDRESS_IN_ACK  : out std_logic;",
"        DATA_IN         : in  std_logic_vector;",
"        DATA_IN_STB     : in  std_logic;",
"        DATA_IN_ACK     : out std_logic;",
"        ADDRESS_OUT     : in  std_logic_vector;",
"        ADDRESS_OUT_STB : in  std_logic;",
"        ADDRESS_OUT_ACK : out std_logic;",
"        DATA_OUT        : out std_logic_vector;",
"        DATA_OUT_STB    : out std_logic;",
"        DATA_OUT_ACK    : in  std_logic",
"    );",
"  end entity RAMARRAY;",
"",
"  architecture RTL of RAMARRAY is",
"",
"    type MEMORY_TYPE is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0);",
"    shared variable MEMORY : MEMORY_TYPE;",
"",
"    type IN_STATE_TYPE is (READ_IN_ADDRESS, ACK_IN_ADDRESS, READ_IN_DATA, ACK_IN_DATA);",
"    signal IN_STATE : IN_STATE_TYPE;",
"",
"    type OUT_STATE_TYPE is (READ_OUT_ADDRESS, ACK_OUT_ADDRESS, WRITE_OUT_DATA);",
"    signal OUT_STATE : OUT_STATE_TYPE;",
"",
"  begin",
"",
"     process",
"      variable ADDRESS : integer range 0 to DEPTH-1;",
"    begin",
"      wait until rising_edge(CLK);",
"      case IN_STATE is",
"",
"        when READ_IN_ADDRESS =>",
"           if ADDRESS_IN_STB = '1' then",
"               ADDRESS := to_integer(unsigned(ADDRESS_IN));",
"               ADDRESS_IN_ACK <= '1';",
"               IN_STATE <= ACK_IN_ADDRESS;",
"           end if;",
"",
"        when ACK_IN_ADDRESS =>",
"           ADDRESS_IN_ACK <= '0';",
"           IN_STATE <= READ_IN_DATA;",
"",
"        when READ_IN_DATA =>",
"           if DATA_IN_STB = '1' then",
"               MEMORY(ADDRESS) := DATA_IN;",
"               DATA_IN_ACK <= '1';",
"               IN_STATE <= ACK_IN_DATA;",
"           end if;",
"",
"        when ACK_IN_DATA =>",
"           DATA_IN_ACK <= '0';",
"           IN_STATE <= READ_IN_ADDRESS;",
"" ,
"        when others => IN_STATE <= READ_IN_ADDRESS;",
"",
"      end case;",
"      if RST = '1' then",
"        DATA_IN_ACK <= '0';",
"        ADDRESS_IN_ACK <= '0';".format(identifier_a),
"        IN_STATE <= READ_IN_ADDRESS;".format(identifier),
"      end if;",
"    end process;",
"",
"    process",
"       variable ADDRESS : integer range 0 to DEPTH-1;",
"    begin",
"      wait until rising_edge(CLK);",
"      case OUT_STATE is",
"",
"        when READ_OUT_ADDRESS =>",
"           if ADDRESS_OUT_STB = '1' then",
"             ADDRESS := to_integer(unsigned(ADDRESS_OUT));",
"             ADDRESS_OUT_ACK <= '1';",
"             OUT_STATE <= ACK_OUT_ADDRESS;",
"           end if;",
"" ,
"        when ACK_OUT_ADDRESS =>",
"           ADDRESS_OUT_ACK <= '0';",
"           OUT_STATE <= WRITE_OUT_DATA;",
"" ,
"        when WRITE_OUT_DATA =>",
"           DATA_OUT <= MEMORY(ADDRESS);",
"           DATA_OUT_STB <= '1';",
"           if DATA_OUT_ACK = '1' then",
"             DATA_OUT_STB <= '0';",
"             OUT_STATE <= READ_OUT_ADDRESS;",
"           end if;",
"",
"        when others => OUT_STATE <= READ_OUT_ADDRESS;",
"" ,
"      end case;",
"      if RST = '1' then",
"        DATA_OUT_STB <= '0';",
"        ADDRESS_OUT_ACK <= '0';".format(identifier_a),
"        OUT_STATE <= READ_OUT_ADDRESS;".format(identifier),
"      end if;",
"  end process;",
"",
"end RTL;",
"--  ****************************************************************************",
"--  End of RAM",
"--  ****************************************************************************",
    ]
    if not one_offs: dependencies = []

    ports = []

    if one_offs:
        declarations = [
"  component RAMARRAY is",
"    generic(",
"        DEPTH : integer;",
"        WIDTH : integer",
"    );",
"    port(",
"        CLK             : in  std_logic;",
"        RST             : in  std_logic;",
"        ADDRESS_IN      : in  std_logic_vector;",
"        ADDRESS_IN_STB  : in  std_logic;",
"        ADDRESS_IN_ACK  : out std_logic;",
"        DATA_IN         : in  std_logic_vector;",
"        DATA_IN_STB     : in  std_logic;",
"        DATA_IN_ACK     : out std_logic;",
"        ADDRESS_OUT     : in  std_logic_vector;",
"        ADDRESS_OUT_STB : in  std_logic;",
"        ADDRESS_OUT_ACK : out std_logic;",
"        DATA_OUT        : out std_logic_vector;",
"        DATA_OUT_STB    : out std_logic;",
"        DATA_OUT_ACK    : in  std_logic",
"    );",
"  end component RAMARRAY;",
"",
"  signal STREAM_{0}     : std_logic_vector({1} downto 0);".format(identifier, bits - 1),
"  signal STREAM_{0}_STB : std_logic;".format(identifier),
"  signal STREAM_{0}_ACK : std_logic;".format(identifier),
"",
        ]
    else:
        declarations = [
"  signal STREAM_{0}     : std_logic_vector({1} downto 0);".format(identifier, bits - 1),
"  signal STREAM_{0}_STB : std_logic;".format(identifier),
"  signal STREAM_{0}_ACK : std_logic;".format(identifier),
"",
        ]


    definitions = [
"  --file: {0}, line: {1}".format(stream.filename, stream.lineno),
"  --STREAM {0} Array()".format(identifier),
"    RAMARRAY_{0} : RAMARRAY generic map(".format(identifier),
"      DEPTH => {0},".format(depth),
"      WIDTH => {0}".format(bits),
"    )",
"    port map(",
"      CLK             => CLK,",
"      RST             => RST,",
"      ADDRESS_IN      => STREAM_{0},".format(identifier_a),
"      ADDRESS_IN_STB  => STREAM_{0}_STB,".format(identifier_a),
"      ADDRESS_IN_ACK  => STREAM_{0}_ACK,".format(identifier_a),
"      DATA_IN         => STREAM_{0},".format(identifier_b),
"      DATA_IN_STB     => STREAM_{0}_STB,".format(identifier_b),
"      DATA_IN_ACK     => STREAM_{0}_ACK,".format(identifier_b),
"      ADDRESS_OUT     => STREAM_{0},".format(identifier_c),
"      ADDRESS_OUT_STB => STREAM_{0}_STB,".format(identifier_c),
"      ADDRESS_OUT_ACK => STREAM_{0}_ACK,".format(identifier_c),
"      DATA_OUT        => STREAM_{0},".format(identifier),
"      DATA_OUT_STB    => STREAM_{0}_STB,".format(identifier),
"      DATA_OUT_ACK    => STREAM_{0}_ACK".format(identifier),
"    );",
"",
    ]

    return dependencies, ports, declarations, definitions
