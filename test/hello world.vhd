--+============================================================================+
--|                                                                            |
--|                     This file was generated by Chips                       |
--|                                                                            |
--|                                  Chips                                     |
--|                                                                            |
--|                      http://github.com/dawsonjon/chips                     |
--|                                                                            |
--|                                                             Python powered |
--+============================================================================+

-- generated by python streams library
-- date generated  : UTC 2011-04-22 21:00:37
-- platform        : linux2
-- python version  : 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) [GCC 4.4.5]
-- streams version : 0.1

--+============================================================================+
--|                             **END OF HEADER**                              |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                    **START OF EXTERNAL DEPENDENCIES**                      |
--+============================================================================+



--+============================================================================+
--|                     **END OF EXTERNAL DEPENDENCIES**                       |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                     **START OF AUTO GENERATED CODE**                       |
--+============================================================================+

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is
  port(
    TX : out std_logic
  );
end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ABSOLUTE(
    A : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(abs(signed(A)));
  end ABSOLUTE;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --logical negation
  function LNOT(
    A : std_logic_vector) return std_logic_vector is
  begin
    if 
      A = std_logic_vector(to_signed(0, A'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LNOT;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;
  constant TIMER_10us_MAX : integer := 49;
  signal TIMER_10us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_10us : std_logic;
  constant TIMER_100us_MAX : integer := 49;
  signal TIMER_100us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_100us : std_logic;
  constant TIMER_1ms_MAX : integer := 49;
  signal TIMER_1ms_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1ms : std_logic;

  signal CLK : std_logic;
  signal RST : std_logic;
  signal STATE_11           : SERIAL_OUT_STATE_TYPE;
  constant CLOCK_DIVIDER_11 : Unsigned(11 downto 0) := To_unsigned(433, 12);
  signal BAUD_COUNT_11      : Unsigned(11 downto 0);
  signal DATA_11            : std_logic_vector(7 downto 0);
  signal X16CLK_EN_11       : std_logic;
  signal STREAM_10     : std_logic_vector(7 downto 0);
  signal STREAM_10_STB : std_logic;
  signal STREAM_10_ACK : std_logic;
  signal STATE_10 : UNARY_STATE_TYPE;
  type LOOKUP_10_TYPE is array (0 to 11) of std_logic_vector(7 downto 0);
  signal LOOKUP_10 : LOOKUP_10_TYPE := (
0 => "01101000",
1 => "01100101",
2 => "01101100",
3 => "01101100",
4 => "01101111",
5 => "01011111",
6 => "01110111",
7 => "01101111",
8 => "01110010",
9 => "01101100",
10 => "01100100",
11 => "00001010"
  );

  signal STREAM_9     : std_logic_vector(4 downto 0);
  signal STREAM_9_STB : std_logic;
  signal STREAM_9_ACK : std_logic;


begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    TIMER_10us <= '0';
    TIMER_100us <= '0';
    TIMER_1ms <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
       if TIMER_10us_COUNT = 0 then
         TIMER_10us_COUNT <= TIMER_10us_MAX;
         TIMER_10us <= '1';
         if TIMER_100us_COUNT = 0 then
           TIMER_100us_COUNT <= TIMER_100us_MAX;
           TIMER_100us <= '1';
           if TIMER_1ms_COUNT = 0 then
             TIMER_1ms_COUNT <= TIMER_1ms_MAX;
             TIMER_1ms <= '1';
           else
             TIMER_1ms_COUNT <= TIMER_1ms_COUNT - 1;
           end if;
         else
           TIMER_100us_COUNT <= TIMER_100us_COUNT - 1;
         end if;
       else
         TIMER_10us_COUNT <= TIMER_10us_COUNT - 1;
       end if;
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
       TIMER_10us_COUNT <= TIMER_10us_MAX;
       TIMER_10us <= '0';
       TIMER_100us_COUNT <= TIMER_100us_MAX;
       TIMER_100us <= '0';
       TIMER_1ms_COUNT <= TIMER_1ms_MAX;
       TIMER_1ms <= '0';
    end if;
  end process;

  --internal clock generator
  process
  begin
    while True loop
      CLK <= '0';
      wait for 5 ns;
      CLK <= '1';
      wait for 5 ns;
    end loop;
    wait;
  end process;

  --internal reset generator
  process
  begin
    RST <= '1';
    wait for 20 ns;
    RST <= '0';
    wait;
  end process;

  --file: None, line: 3
  --serial output port baud rate generator
  process
  begin
    wait until rising_edge(CLK);
    if BAUD_COUNT_11 = CLOCK_DIVIDER_11 then
      BAUD_COUNT_11 <= (others => '0');
      X16CLK_EN_11  <= '1';
    else
      BAUD_COUNT_11 <= BAUD_COUNT_11 + 1;
      X16CLK_EN_11  <= '0';
    end if;
    if RST = '1' then
      BAUD_COUNT_11 <= (others => '0');
      X16CLK_EN_11  <= '0';
    end if;
  end process;

  process
  begin
    wait until rising_edge(CLK);
    case STATE_11 is
      when IDLE =>
        if STREAM_10_STB = '1'  then
          STREAM_10_ACK <= '1';
          DATA_11 <= STREAM_10;
          STATE_11     <= WAIT_EN;
        end if;
      when WAIT_EN =>
        STREAM_10_ACK <= '0';
        if X16CLK_EN_11 = '1' then
          STATE_11 <= START;
        end if;
      when START =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX0;
        end if;
        TX <= '0'; 
      when TX0 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX1;
        end if;
        TX <= DATA_11(0);
      when TX1 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX2;
        end if;
        TX <= DATA_11(1);
      when TX2 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX3;
        end if;
        TX <= DATA_11(2);
      when TX3 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX4;
        end if;
        TX <= DATA_11(3);
      when TX4 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX5;
        end if;
        TX <= DATA_11(4);
      when TX5 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX6;
        end if;
        TX <= DATA_11(5);
      when TX6 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= TX7;
        end if;
        TX <= DATA_11(6);
      when TX7 =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= STOP;
        end if;
        TX <= DATA_11(7);
      when STOP =>
        if X16CLK_EN_11 = '1' then
          STATE_11 <= IDLE;
        end if;
        TX <= '1';
      when others =>
        STATE_11 <= IDLE;
      end case;
    if RST = '1' then
      STREAM_10_ACK <= '0';
      STATE_11 <= IDLE;
    end if; 
  end process;
  --file: /usr/local/lib/python2.6/dist-packages/chips/__init__.py, line: 87
  --STREAM 10 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_10 is
      when UNARY_INPUT =>
        if STREAM_9_STB = '1' then
          STREAM_9_ACK <= '1';
          STREAM_10_STB <= '1';
          STREAM_10 <= LOOKUP_10(to_integer(unsigned(STREAM_9)));
          STATE_10 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_9_ACK <= '0';
        if STREAM_10_ACK = '1' then
           STREAM_10_STB <= '0';
           STATE_10 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_10_STB <= '0';
       STREAM_9_ACK <= '0';
       STATE_10 <= UNARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/chips/__init__.py, line: 87
  --STREAM 9 Counter(0, 11, 1, 5)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_9_STB <= '1';
    if STREAM_9_ACK = '1' then
      STREAM_9_STB <= '0';
      STREAM_9 <= STD_RESIZE(ADD(STREAM_9, "00001"), 5);
      if STREAM_9 = "01011" then
        STREAM_9 <= "00000";
      end if;
    end if;
    if RST = '1' then
      STREAM_9_STB <= '0';
      STREAM_9 <= "00000";
    end if;
  end process;


end architecture RTL;

--+============================================================================+
--|                       **END OF AUTO GENERATED CODE**                       |
--+============================================================================+