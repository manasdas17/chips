--+============================================================================+
--|   **THIS FILE WAS AUTOMATICALLY GENERATED BY THE PYTHON STREAMS LIBRARY**  |
--+ ============================================================================+
--|                    _       ________________                                |
--|                   (_)---->/                /     _                         |
--|                    _     / PYTHON STREAMS /---->(_)                        |
--|                   (_)-->/________________/                                 |
--|                                                                            |
--+============================================================================+

-- generated by python streams library
-- date generated  : UTC 2011-02-18 19:31:09
-- platform        : linux2
-- python version  : 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) 
--                   [GCC 4.4.5]
-- streams version : 0.1

--+============================================================================+
--|                             **END OF HEADER**                              |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                    **START OF EXTERNAL DEPENDENCIES**                      |
--+============================================================================+



--+============================================================================+
--|                     **END OF EXTERNAL DEPENDENCIES**                       |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                     **START OF AUTO GENERATED CODE**                       |
--+============================================================================+

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is

end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;
  constant TIMER_10us_MAX : integer := 49;
  signal TIMER_10us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_10us : std_logic;
  constant TIMER_100us_MAX : integer := 49;
  signal TIMER_100us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_100us : std_logic;
  constant TIMER_1ms_MAX : integer := 49;
  signal TIMER_1ms_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1ms : std_logic;

  signal CLK : std_logic;
  signal RST : std_logic;
  signal STATE_57      : BINARY_STATE_TYPE;
  signal STREAM_57     : std_logic_vector(0 downto 0);
  signal STREAM_57_STB : std_logic;
  signal STREAM_57_ACK : std_logic;

  signal STREAM_54     : std_logic_vector(4 downto 0);
  signal STREAM_54_STB : std_logic;
  signal STREAM_54_ACK : std_logic;
  signal STATE_54 : UNARY_STATE_TYPE;
  type LOOKUP_54_TYPE is array (0 to 255) of std_logic_vector(4 downto 0);
  signal LOOKUP_54 : LOOKUP_54_TYPE := (
0 => "00000",
1 => "11111",
2 => "11110",
3 => "11101",
4 => "11100",
5 => "11011",
6 => "11010",
7 => "11001",
8 => "11000",
9 => "10111",
10 => "10110",
11 => "10101",
12 => "10100",
13 => "10011",
14 => "10010",
15 => "10001",
16 => "00001",
17 => "00000",
18 => "11111",
19 => "11110",
20 => "11101",
21 => "11100",
22 => "11011",
23 => "11010",
24 => "11001",
25 => "11000",
26 => "10111",
27 => "10110",
28 => "10101",
29 => "10100",
30 => "10011",
31 => "10010",
32 => "00010",
33 => "00001",
34 => "00000",
35 => "11111",
36 => "11110",
37 => "11101",
38 => "11100",
39 => "11011",
40 => "11010",
41 => "11001",
42 => "11000",
43 => "10111",
44 => "10110",
45 => "10101",
46 => "10100",
47 => "10011",
48 => "00011",
49 => "00010",
50 => "00001",
51 => "00000",
52 => "11111",
53 => "11110",
54 => "11101",
55 => "11100",
56 => "11011",
57 => "11010",
58 => "11001",
59 => "11000",
60 => "10111",
61 => "10110",
62 => "10101",
63 => "10100",
64 => "00100",
65 => "00011",
66 => "00010",
67 => "00001",
68 => "00000",
69 => "11111",
70 => "11110",
71 => "11101",
72 => "11100",
73 => "11011",
74 => "11010",
75 => "11001",
76 => "11000",
77 => "10111",
78 => "10110",
79 => "10101",
80 => "00101",
81 => "00100",
82 => "00011",
83 => "00010",
84 => "00001",
85 => "00000",
86 => "11111",
87 => "11110",
88 => "11101",
89 => "11100",
90 => "11011",
91 => "11010",
92 => "11001",
93 => "11000",
94 => "10111",
95 => "10110",
96 => "00110",
97 => "00101",
98 => "00100",
99 => "00011",
100 => "00010",
101 => "00001",
102 => "00000",
103 => "11111",
104 => "11110",
105 => "11101",
106 => "11100",
107 => "11011",
108 => "11010",
109 => "11001",
110 => "11000",
111 => "10111",
112 => "00111",
113 => "00110",
114 => "00101",
115 => "00100",
116 => "00011",
117 => "00010",
118 => "00001",
119 => "00000",
120 => "11111",
121 => "11110",
122 => "11101",
123 => "11100",
124 => "11011",
125 => "11010",
126 => "11001",
127 => "11000",
128 => "01000",
129 => "00111",
130 => "00110",
131 => "00101",
132 => "00100",
133 => "00011",
134 => "00010",
135 => "00001",
136 => "00000",
137 => "11111",
138 => "11110",
139 => "11101",
140 => "11100",
141 => "11011",
142 => "11010",
143 => "11001",
144 => "01001",
145 => "01000",
146 => "00111",
147 => "00110",
148 => "00101",
149 => "00100",
150 => "00011",
151 => "00010",
152 => "00001",
153 => "00000",
154 => "11111",
155 => "11110",
156 => "11101",
157 => "11100",
158 => "11011",
159 => "11010",
160 => "01010",
161 => "01001",
162 => "01000",
163 => "00111",
164 => "00110",
165 => "00101",
166 => "00100",
167 => "00011",
168 => "00010",
169 => "00001",
170 => "00000",
171 => "11111",
172 => "11110",
173 => "11101",
174 => "11100",
175 => "11011",
176 => "01011",
177 => "01010",
178 => "01001",
179 => "01000",
180 => "00111",
181 => "00110",
182 => "00101",
183 => "00100",
184 => "00011",
185 => "00010",
186 => "00001",
187 => "00000",
188 => "11111",
189 => "11110",
190 => "11101",
191 => "11100",
192 => "01100",
193 => "01011",
194 => "01010",
195 => "01001",
196 => "01000",
197 => "00111",
198 => "00110",
199 => "00101",
200 => "00100",
201 => "00011",
202 => "00010",
203 => "00001",
204 => "00000",
205 => "11111",
206 => "11110",
207 => "11101",
208 => "01101",
209 => "01100",
210 => "01011",
211 => "01010",
212 => "01001",
213 => "01000",
214 => "00111",
215 => "00110",
216 => "00101",
217 => "00100",
218 => "00011",
219 => "00010",
220 => "00001",
221 => "00000",
222 => "11111",
223 => "11110",
224 => "01110",
225 => "01101",
226 => "01100",
227 => "01011",
228 => "01010",
229 => "01001",
230 => "01000",
231 => "00111",
232 => "00110",
233 => "00101",
234 => "00100",
235 => "00011",
236 => "00010",
237 => "00001",
238 => "00000",
239 => "11111",
240 => "01111",
241 => "01110",
242 => "01101",
243 => "01100",
244 => "01011",
245 => "01010",
246 => "01001",
247 => "01000",
248 => "00111",
249 => "00110",
250 => "00101",
251 => "00100",
252 => "00011",
253 => "00010",
254 => "00001",
255 => "00000"
  );

  signal STREAM_53     : std_logic_vector(8 downto 0);
  signal STREAM_53_STB : std_logic;
  signal STREAM_53_ACK : std_logic;

  signal STREAM_50     : std_logic_vector(3 downto 0);
  signal STREAM_50_STB : std_logic;
  signal STREAM_50_ACK : std_logic;
  signal STATE_50 : UNARY_STATE_TYPE;
  type LOOKUP_50_TYPE is array (0 to 255) of std_logic_vector(3 downto 0);
  signal LOOKUP_50 : LOOKUP_50_TYPE := (
0 => "1000",
1 => "1000",
2 => "1000",
3 => "1000",
4 => "1000",
5 => "1000",
6 => "1000",
7 => "1000",
8 => "1000",
9 => "1000",
10 => "1000",
11 => "1000",
12 => "1000",
13 => "1000",
14 => "1000",
15 => "1000",
16 => "1001",
17 => "1001",
18 => "1001",
19 => "1001",
20 => "1001",
21 => "1001",
22 => "1001",
23 => "1001",
24 => "1001",
25 => "1001",
26 => "1001",
27 => "1001",
28 => "1001",
29 => "1001",
30 => "1001",
31 => "1001",
32 => "1010",
33 => "1010",
34 => "1010",
35 => "1010",
36 => "1010",
37 => "1010",
38 => "1010",
39 => "1010",
40 => "1010",
41 => "1010",
42 => "1010",
43 => "1010",
44 => "1010",
45 => "1010",
46 => "1010",
47 => "1010",
48 => "1011",
49 => "1011",
50 => "1011",
51 => "1011",
52 => "1011",
53 => "1011",
54 => "1011",
55 => "1011",
56 => "1011",
57 => "1011",
58 => "1011",
59 => "1011",
60 => "1011",
61 => "1011",
62 => "1011",
63 => "1011",
64 => "1100",
65 => "1100",
66 => "1100",
67 => "1100",
68 => "1100",
69 => "1100",
70 => "1100",
71 => "1100",
72 => "1100",
73 => "1100",
74 => "1100",
75 => "1100",
76 => "1100",
77 => "1100",
78 => "1100",
79 => "1100",
80 => "1101",
81 => "1101",
82 => "1101",
83 => "1101",
84 => "1101",
85 => "1101",
86 => "1101",
87 => "1101",
88 => "1101",
89 => "1101",
90 => "1101",
91 => "1101",
92 => "1101",
93 => "1101",
94 => "1101",
95 => "1101",
96 => "1110",
97 => "1110",
98 => "1110",
99 => "1110",
100 => "1110",
101 => "1110",
102 => "1110",
103 => "1110",
104 => "1110",
105 => "1110",
106 => "1110",
107 => "1110",
108 => "1110",
109 => "1110",
110 => "1110",
111 => "1110",
112 => "1111",
113 => "1111",
114 => "1111",
115 => "1111",
116 => "1111",
117 => "1111",
118 => "1111",
119 => "1111",
120 => "1111",
121 => "1111",
122 => "1111",
123 => "1111",
124 => "1111",
125 => "1111",
126 => "1111",
127 => "1111",
128 => "0000",
129 => "0000",
130 => "0000",
131 => "0000",
132 => "0000",
133 => "0000",
134 => "0000",
135 => "0000",
136 => "0000",
137 => "0000",
138 => "0000",
139 => "0000",
140 => "0000",
141 => "0000",
142 => "0000",
143 => "0000",
144 => "0001",
145 => "0001",
146 => "0001",
147 => "0001",
148 => "0001",
149 => "0001",
150 => "0001",
151 => "0001",
152 => "0001",
153 => "0001",
154 => "0001",
155 => "0001",
156 => "0001",
157 => "0001",
158 => "0001",
159 => "0001",
160 => "0010",
161 => "0010",
162 => "0010",
163 => "0010",
164 => "0010",
165 => "0010",
166 => "0010",
167 => "0010",
168 => "0010",
169 => "0010",
170 => "0010",
171 => "0010",
172 => "0010",
173 => "0010",
174 => "0010",
175 => "0010",
176 => "0011",
177 => "0011",
178 => "0011",
179 => "0011",
180 => "0011",
181 => "0011",
182 => "0011",
183 => "0011",
184 => "0011",
185 => "0011",
186 => "0011",
187 => "0011",
188 => "0011",
189 => "0011",
190 => "0011",
191 => "0011",
192 => "0100",
193 => "0100",
194 => "0100",
195 => "0100",
196 => "0100",
197 => "0100",
198 => "0100",
199 => "0100",
200 => "0100",
201 => "0100",
202 => "0100",
203 => "0100",
204 => "0100",
205 => "0100",
206 => "0100",
207 => "0100",
208 => "0101",
209 => "0101",
210 => "0101",
211 => "0101",
212 => "0101",
213 => "0101",
214 => "0101",
215 => "0101",
216 => "0101",
217 => "0101",
218 => "0101",
219 => "0101",
220 => "0101",
221 => "0101",
222 => "0101",
223 => "0101",
224 => "0110",
225 => "0110",
226 => "0110",
227 => "0110",
228 => "0110",
229 => "0110",
230 => "0110",
231 => "0110",
232 => "0110",
233 => "0110",
234 => "0110",
235 => "0110",
236 => "0110",
237 => "0110",
238 => "0110",
239 => "0110",
240 => "0111",
241 => "0111",
242 => "0111",
243 => "0111",
244 => "0111",
245 => "0111",
246 => "0111",
247 => "0111",
248 => "0111",
249 => "0111",
250 => "0111",
251 => "0111",
252 => "0111",
253 => "0111",
254 => "0111",
255 => "0111"
  );

  signal STREAM_49     : std_logic_vector(8 downto 0);
  signal STREAM_49_STB : std_logic;
  signal STREAM_49_ACK : std_logic;

  signal STREAM_52     : std_logic_vector(3 downto 0);
  signal STREAM_52_STB : std_logic;
  signal STREAM_52_ACK : std_logic;
  signal STATE_52 : UNARY_STATE_TYPE;
  type LOOKUP_52_TYPE is array (0 to 255) of std_logic_vector(3 downto 0);
  signal LOOKUP_52 : LOOKUP_52_TYPE := (
0 => "1000",
1 => "1001",
2 => "1010",
3 => "1011",
4 => "1100",
5 => "1101",
6 => "1110",
7 => "1111",
8 => "0000",
9 => "0001",
10 => "0010",
11 => "0011",
12 => "0100",
13 => "0101",
14 => "0110",
15 => "0111",
16 => "1000",
17 => "1001",
18 => "1010",
19 => "1011",
20 => "1100",
21 => "1101",
22 => "1110",
23 => "1111",
24 => "0000",
25 => "0001",
26 => "0010",
27 => "0011",
28 => "0100",
29 => "0101",
30 => "0110",
31 => "0111",
32 => "1000",
33 => "1001",
34 => "1010",
35 => "1011",
36 => "1100",
37 => "1101",
38 => "1110",
39 => "1111",
40 => "0000",
41 => "0001",
42 => "0010",
43 => "0011",
44 => "0100",
45 => "0101",
46 => "0110",
47 => "0111",
48 => "1000",
49 => "1001",
50 => "1010",
51 => "1011",
52 => "1100",
53 => "1101",
54 => "1110",
55 => "1111",
56 => "0000",
57 => "0001",
58 => "0010",
59 => "0011",
60 => "0100",
61 => "0101",
62 => "0110",
63 => "0111",
64 => "1000",
65 => "1001",
66 => "1010",
67 => "1011",
68 => "1100",
69 => "1101",
70 => "1110",
71 => "1111",
72 => "0000",
73 => "0001",
74 => "0010",
75 => "0011",
76 => "0100",
77 => "0101",
78 => "0110",
79 => "0111",
80 => "1000",
81 => "1001",
82 => "1010",
83 => "1011",
84 => "1100",
85 => "1101",
86 => "1110",
87 => "1111",
88 => "0000",
89 => "0001",
90 => "0010",
91 => "0011",
92 => "0100",
93 => "0101",
94 => "0110",
95 => "0111",
96 => "1000",
97 => "1001",
98 => "1010",
99 => "1011",
100 => "1100",
101 => "1101",
102 => "1110",
103 => "1111",
104 => "0000",
105 => "0001",
106 => "0010",
107 => "0011",
108 => "0100",
109 => "0101",
110 => "0110",
111 => "0111",
112 => "1000",
113 => "1001",
114 => "1010",
115 => "1011",
116 => "1100",
117 => "1101",
118 => "1110",
119 => "1111",
120 => "0000",
121 => "0001",
122 => "0010",
123 => "0011",
124 => "0100",
125 => "0101",
126 => "0110",
127 => "0111",
128 => "1000",
129 => "1001",
130 => "1010",
131 => "1011",
132 => "1100",
133 => "1101",
134 => "1110",
135 => "1111",
136 => "0000",
137 => "0001",
138 => "0010",
139 => "0011",
140 => "0100",
141 => "0101",
142 => "0110",
143 => "0111",
144 => "1000",
145 => "1001",
146 => "1010",
147 => "1011",
148 => "1100",
149 => "1101",
150 => "1110",
151 => "1111",
152 => "0000",
153 => "0001",
154 => "0010",
155 => "0011",
156 => "0100",
157 => "0101",
158 => "0110",
159 => "0111",
160 => "1000",
161 => "1001",
162 => "1010",
163 => "1011",
164 => "1100",
165 => "1101",
166 => "1110",
167 => "1111",
168 => "0000",
169 => "0001",
170 => "0010",
171 => "0011",
172 => "0100",
173 => "0101",
174 => "0110",
175 => "0111",
176 => "1000",
177 => "1001",
178 => "1010",
179 => "1011",
180 => "1100",
181 => "1101",
182 => "1110",
183 => "1111",
184 => "0000",
185 => "0001",
186 => "0010",
187 => "0011",
188 => "0100",
189 => "0101",
190 => "0110",
191 => "0111",
192 => "1000",
193 => "1001",
194 => "1010",
195 => "1011",
196 => "1100",
197 => "1101",
198 => "1110",
199 => "1111",
200 => "0000",
201 => "0001",
202 => "0010",
203 => "0011",
204 => "0100",
205 => "0101",
206 => "0110",
207 => "0111",
208 => "1000",
209 => "1001",
210 => "1010",
211 => "1011",
212 => "1100",
213 => "1101",
214 => "1110",
215 => "1111",
216 => "0000",
217 => "0001",
218 => "0010",
219 => "0011",
220 => "0100",
221 => "0101",
222 => "0110",
223 => "0111",
224 => "1000",
225 => "1001",
226 => "1010",
227 => "1011",
228 => "1100",
229 => "1101",
230 => "1110",
231 => "1111",
232 => "0000",
233 => "0001",
234 => "0010",
235 => "0011",
236 => "0100",
237 => "0101",
238 => "0110",
239 => "0111",
240 => "1000",
241 => "1001",
242 => "1010",
243 => "1011",
244 => "1100",
245 => "1101",
246 => "1110",
247 => "1111",
248 => "0000",
249 => "0001",
250 => "0010",
251 => "0011",
252 => "0100",
253 => "0101",
254 => "0110",
255 => "0111"
  );

  signal STREAM_51     : std_logic_vector(8 downto 0);
  signal STREAM_51_STB : std_logic;
  signal STREAM_51_ACK : std_logic;

  signal STREAM_55       : std_logic_vector(7 downto 0);
  signal STREAM_55_STB   : std_logic;
  signal STREAM_55_ACK   : std_logic;
  constant OP_ADD_56 : std_logic_vector(4 downto 0) := "00000";
  constant OP_SUB_56 : std_logic_vector(4 downto 0) := "00001";
  constant OP_MUL_56 : std_logic_vector(4 downto 0) := "00010";
  constant OP_DIV_56 : std_logic_vector(4 downto 0) := "00011";
  constant OP_BAND_56 : std_logic_vector(4 downto 0) := "00100";
  constant OP_BOR_56 : std_logic_vector(4 downto 0) := "00101";
  constant OP_BXOR_56 : std_logic_vector(4 downto 0) := "00110";
  constant OP_SL_56 : std_logic_vector(4 downto 0) := "00111";
  constant OP_SR_56 : std_logic_vector(4 downto 0) := "01000";
  constant OP_EQ_56 : std_logic_vector(4 downto 0) := "01001";
  constant OP_NE_56 : std_logic_vector(4 downto 0) := "01010";
  constant OP_GT_56 : std_logic_vector(4 downto 0) := "01011";
  constant OP_GE_56 : std_logic_vector(4 downto 0) := "01100";
  constant OP_JMP_56 : std_logic_vector(4 downto 0) := "01101";
  constant OP_JMPF_56 : std_logic_vector(4 downto 0) := "01110";
  constant OP_IMM_56 : std_logic_vector(4 downto 0) := "01111";
  constant OP_MOVE_56 : std_logic_vector(4 downto 0) := "10000";
  constant OP_WAIT_US_56 : std_logic_vector(4 downto 0) := "10001";
  constant OP_MOD_56 : std_logic_vector(4 downto 0) := "10010";
  constant OP_READ_50_56 : std_logic_vector(4 downto 0) := "10011";
  constant OP_READ_52_56 : std_logic_vector(4 downto 0) := "10100";
  constant OP_WRITE_55_56 : std_logic_vector(4 downto 0) := "10101";
  type PROCESS_56_STATE_TYPE is (STALL, EXECUTE, WAIT_US, READ_STREAM_50, ACK_STREAM_50, READ_STREAM_52, ACK_STREAM_52, WRITE_STREAM_55);
  type INSTRUCTIONS_TYPE_56  is array (0 to 10) of std_logic_vector(15 downto 0);
  type REGISTERS_TYPE_56     is array (0 to 7) of std_logic_vector(7 downto 0);
  signal STATE_56        : PROCESS_56_STATE_TYPE;
  signal REGISTERS_56    : REGISTERS_TYPE_56;
  signal PC_56           : unsigned(3 downto 0);
  signal OPERATION_56    : std_logic_vector(4 downto 0);
  signal SRCA_56         : std_logic_vector(2 downto 0);
  signal SRCB_56         : std_logic_vector(2 downto 0);
  signal IMMEDIATE_56    : std_logic_vector(7 downto 0);
  signal ZERO_56         : std_logic;
  signal A_56            : std_logic_vector(7 downto 0);
  signal B_56            : std_logic_vector(7 downto 0);
  signal QUOTIENT_56     : std_logic_vector(7 downto 0);
  signal SHIFTER_56      : std_logic_vector(7 downto 0);
  signal REMAINDER_56    : std_logic_vector(7 downto 0);
  signal COUNT_56        : integer range 0 to 8;
  signal SIGN_56         : std_logic;
  signal INSTRUCTIONS_56 : INSTRUCTIONS_TYPE_56 := (
0 => OP_IMM_56 & "001" & "00000000", -- file: /usr/local/bin/test_streams_VHDL.py line: 194
1 => OP_IMM_56 & "010" & "00000000", -- file: /usr/local/bin/test_streams_VHDL.py line: 195
2 => OP_READ_50_56 & "001" & "00000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/streams.py line: 148
3 => OP_READ_52_56 & "010" & "00000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/streams.py line: 148
4 => OP_MOVE_56 & "011" & "00000001", -- file: /usr/local/bin/test_streams_VHDL.py line: 194
5 => OP_MOVE_56 & "100" & "00000010", -- file: /usr/local/bin/test_streams_VHDL.py line: 195
6 => OP_SUB_56 & "011" & "00000100", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 115
7 => OP_WRITE_55_56 & "011" & "00000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/streams.py line: 371
8 => OP_JMP_56 & "000" & "00000010", -- file: /usr/local/bin/test_streams_VHDL.py line: 200
9 => OP_JMP_56 & "000" & "00001001", -- file: None line: None
10 => OP_JMP_56 & "000" & "00000000"); -- file: None line: None
  signal MOD_DIV_56      : std_logic;

begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    TIMER_10us <= '0';
    TIMER_100us <= '0';
    TIMER_1ms <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
       if TIMER_10us_COUNT = 0 then
         TIMER_10us_COUNT <= TIMER_10us_MAX;
         TIMER_10us <= '1';
         if TIMER_100us_COUNT = 0 then
           TIMER_100us_COUNT <= TIMER_100us_MAX;
           TIMER_100us <= '1';
           if TIMER_1ms_COUNT = 0 then
             TIMER_1ms_COUNT <= TIMER_1ms_MAX;
             TIMER_1ms <= '1';
           else
             TIMER_1ms_COUNT <= TIMER_1ms_COUNT - 1;
           end if;
         else
           TIMER_100us_COUNT <= TIMER_100us_COUNT - 1;
         end if;
       else
         TIMER_10us_COUNT <= TIMER_10us_COUNT - 1;
       end if;
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
       TIMER_10us_COUNT <= TIMER_10us_MAX;
       TIMER_10us <= '0';
       TIMER_100us_COUNT <= TIMER_100us_MAX;
       TIMER_100us <= '0';
       TIMER_1ms_COUNT <= TIMER_1ms_MAX;
       TIMER_1ms <= '0';
    end if;
  end process;

  --internal clock generator
  process
  begin
    while True loop
      CLK <= '0';
      wait for 5 ns;
      CLK <= '1';
      wait for 5 ns;
    end loop;
    wait;
  end process;

  --internal reset generator
  process
  begin
    RST <= '1';
    wait for 20 ns;
    RST <= '0';
    wait;
  end process;

  --file: /usr/local/bin/test_streams_VHDL.py, line: 202
  --Asserter(57)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_57_ACK <= '0';
    if STREAM_57_STB = '1' and STREAM_57_ACK = '0' then
      assert(STREAM_57 /= "0") severity failure;
      STREAM_57_ACK <= '1';
    end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/streams.py, line: 125
  --STREAM 57 Binary(54, 55, 'eq')
  process
  begin
    wait until rising_edge(CLK);
    case STATE_57 is
      when BINARY_INPUT =>
        if STREAM_54_STB = '1' and STREAM_55_STB = '1' then
          STREAM_54_ACK <= '1'; STREAM_55_ACK <= '1';
          STREAM_57 <= EQ(  STREAM_54, STREAM_55);
          STREAM_57_STB <= '1';
          STATE_57 <= BINARY_OUTPUT;
        end if;
      when BINARY_OUTPUT =>
        STREAM_54_ACK <= '0'; STREAM_55_ACK <= '0';
        if STREAM_57_ACK = '1' then
           STREAM_57_STB <= '0';
           STATE_57 <= BINARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_57_STB <= '0';
       STREAM_54_ACK <= '0';
       STREAM_55_ACK <= '0';
       STATE_57 <= BINARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 57
  --STREAM 54 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_54 is
      when UNARY_INPUT =>
        if STREAM_53_STB = '1' then
          STREAM_53_ACK <= '1';
          STREAM_54_STB <= '1';
          STREAM_54 <= LOOKUP_54(to_integer(unsigned(STREAM_53)));
          STATE_54 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_53_ACK <= '0';
        if STREAM_54_ACK = '1' then
           STREAM_54_STB <= '0';
           STATE_54 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_54_STB <= '0';
       STREAM_53_ACK <= '0';
       STATE_54 <= UNARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 57
  --STREAM 53 Counter(0, 255, 1, 9)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_53_STB <= '1';
    if STREAM_53_ACK = '1' then
      STREAM_53_STB <= '0';
      STREAM_53 <= STD_RESIZE(ADD(STREAM_53, "000000001"), 9);
      if STREAM_53 = "011111111" then
        STREAM_53 <= "000000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_53_STB <= '0';
      STREAM_53 <= "000000000";
    end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 57
  --STREAM 50 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_50 is
      when UNARY_INPUT =>
        if STREAM_49_STB = '1' then
          STREAM_49_ACK <= '1';
          STREAM_50_STB <= '1';
          STREAM_50 <= LOOKUP_50(to_integer(unsigned(STREAM_49)));
          STATE_50 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_49_ACK <= '0';
        if STREAM_50_ACK = '1' then
           STREAM_50_STB <= '0';
           STATE_50 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_50_STB <= '0';
       STREAM_49_ACK <= '0';
       STATE_50 <= UNARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 57
  --STREAM 49 Counter(0, 255, 1, 9)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_49_STB <= '1';
    if STREAM_49_ACK = '1' then
      STREAM_49_STB <= '0';
      STREAM_49 <= STD_RESIZE(ADD(STREAM_49, "000000001"), 9);
      if STREAM_49 = "011111111" then
        STREAM_49 <= "000000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_49_STB <= '0';
      STREAM_49 <= "000000000";
    end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 57
  --STREAM 52 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_52 is
      when UNARY_INPUT =>
        if STREAM_51_STB = '1' then
          STREAM_51_ACK <= '1';
          STREAM_52_STB <= '1';
          STREAM_52 <= LOOKUP_52(to_integer(unsigned(STREAM_51)));
          STATE_52 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_51_ACK <= '0';
        if STREAM_52_ACK = '1' then
           STREAM_52_STB <= '0';
           STATE_52 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_52_STB <= '0';
       STREAM_51_ACK <= '0';
       STATE_52 <= UNARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 57
  --STREAM 51 Counter(0, 255, 1, 9)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_51_STB <= '1';
    if STREAM_51_ACK = '1' then
      STREAM_51_STB <= '0';
      STREAM_51 <= STD_RESIZE(ADD(STREAM_51, "000000001"), 9);
      if STREAM_51 = "011111111" then
        STREAM_51 <= "000000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_51_STB <= '0';
      STREAM_51 <= "000000000";
    end if;
  end process;

  -- process
  process
    variable INSTRUCTION : std_logic_vector(15 downto 0);
  begin
    wait until rising_edge(CLK);
    INSTRUCTION := INSTRUCTIONS_56(to_integer(PC_56));
    OPERATION_56 <= INSTRUCTION(15 downto 11);
    SRCA_56      <= INSTRUCTION(10 downto 8);
    SRCB_56      <= INSTRUCTION(2 downto 0);
    IMMEDIATE_56 <= INSTRUCTION(7 downto 0);
  end process;

  process
    variable REGA    : std_logic_vector(7 downto 0);
    variable REGB    : std_logic_vector(7 downto 0);
    variable DEST    : std_logic_vector(2 downto 0);
    variable RESULT  : std_logic_vector(7 downto 0);
    variable REGISTERS_EN  : std_logic;
    variable MODULO  : unsigned(7 downto 0);
    variable FLAG_EQ : std_logic;
    variable FLAG_NE : std_logic;
    variable FLAG_GT : std_logic;
    variable FLAG_GE : std_logic;
  begin
    wait until rising_edge(CLK);
    REGISTERS_EN := '0';
    case STATE_56 is
      when STALL =>
        PC_56 <= PC_56 + 1;
        STATE_56 <= EXECUTE;
      when EXECUTE =>
        REGA := REGISTERS_56(to_integer(unsigned(SRCA_56)));
        REGB := REGISTERS_56(to_integer(unsigned(SRCB_56)));
        DEST := SRCA_56;
        RESULT := REGA;
        PC_56 <= PC_56 + 1;

        --share comparator logic
        if REGA = REGB then
          FLAG_EQ := '1';
        else
          FLAG_EQ := '0';
        end if;

        if signed(REGA) > signed(REGB) then
          FLAG_GT := '1';
        else
          FLAG_GT := '0';
        end if;

        FLAG_NE := not FLAG_EQ;
        FLAG_GE := FLAG_GT or FLAG_EQ;

        --execute instructions
        case OPERATION_56 is
          when OP_MOVE_56 => 
            RESULT := REGB;
            REGISTERS_EN := '1';
          when OP_MUL_56  => 
            RESULT := STD_RESIZE( MUL(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_ADD_56  => 
            RESULT := STD_RESIZE( ADD(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_SUB_56  => 
            RESULT := STD_RESIZE( SUB(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_BAND_56 => 
            RESULT := STD_RESIZE(BAND(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_BOR_56  => 
            RESULT := STD_RESIZE( BOR(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_BXOR_56 => 
            RESULT := STD_RESIZE(BXOR(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_SL_56   => 
            RESULT := STD_RESIZE(  SL(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_SR_56   => 
            RESULT := STD_RESIZE(  SR(REGA, REGB), 8);
            REGISTERS_EN := '1';
          when OP_EQ_56   => 
            RESULT := (others => FLAG_EQ);
            REGISTERS_EN := '1';
          when OP_NE_56   => 
            RESULT := (others => FLAG_NE);
            REGISTERS_EN := '1';
          when OP_GT_56   => 
            RESULT := (others => FLAG_GT);
            REGISTERS_EN := '1';
          when OP_GE_56   => 
            RESULT := (others => FLAG_GE);
            REGISTERS_EN := '1';
          when OP_IMM_56  => 
            RESULT := IMMEDIATE_56;
            REGISTERS_EN := '1';
          when OP_JMP_56 =>
            STATE_56 <= STALL;
            PC_56 <= resize(unsigned(IMMEDIATE_56), 4);
          when OP_JMPF_56 =>
            if ZERO_56 = '1' then
              STATE_56 <= STALL;
              PC_56 <= resize(unsigned(IMMEDIATE_56), 4);
            end if;
          when OP_WAIT_US_56 =>
            STATE_56 <= WAIT_US;
            PC_56 <= PC_56;

          when OP_WRITE_55_56 =>
            STATE_56 <= WRITE_STREAM_55;
            DEST := SRCA_56;
            PC_56 <= PC_56;
          when OP_READ_50_56 =>
            STATE_56 <= READ_STREAM_50;
            PC_56 <= PC_56;
          when OP_READ_52_56 =>
            STATE_56 <= READ_STREAM_52;
            PC_56 <= PC_56;
          when others => null;
        end case;

        --write back results
        if RESULT = "00000000" then
          ZERO_56 <= '1';
        else
          ZERO_56 <= '0';
        end if;

      when READ_STREAM_50 =>
        if STREAM_50_STB = '1' then
          STREAM_50_ACK <= '1';
          REGISTERS_EN := '1';
          RESULT := STD_RESIZE(STREAM_50, 8);
          STATE_56 <= ACK_STREAM_50;
        end if;
      when ACK_STREAM_50 =>
        STREAM_50_ACK <= '0';
        STATE_56 <= EXECUTE;
        PC_56 <= PC_56 + 1;
      when READ_STREAM_52 =>
        if STREAM_52_STB = '1' then
          STREAM_52_ACK <= '1';
          REGISTERS_EN := '1';
          RESULT := STD_RESIZE(STREAM_52, 8);
          STATE_56 <= ACK_STREAM_52;
        end if;
      when ACK_STREAM_52 =>
        STREAM_52_ACK <= '0';
        STATE_56 <= EXECUTE;
        PC_56 <= PC_56 + 1;
      when WRITE_STREAM_55 =>
        STREAM_55_STB <= '1';
        STREAM_55 <= STD_RESIZE(REGA, 8);
        if STREAM_55_ACK = '1' then
          STREAM_55_STB <= '0';
          STATE_56 <= EXECUTE;
          PC_56 <= PC_56 + 1;
        end if;
      when WAIT_US =>
        if TIMER_1uS = '1'then
          PC_56 <= PC_56 + 1;
          STATE_56 <= EXECUTE;
        end if;
    end case;

    if RST = '1' then
      STATE_56 <= STALL;
      PC_56 <= "0000";
      STREAM_50_ACK <= '0';
      STREAM_52_ACK <= '0';
      STREAM_55_STB <= '0';
    end if;
    if REGISTERS_EN = '1' then
      REGISTERS_56(to_integer(unsigned(DEST))) <= RESULT;
    end if;
  end process;



end architecture RTL;

--+============================================================================+
--|                       **END OF AUTO GENERATED CODE**                       |
--+============================================================================+