-- generated by python streams library
-- date generated  : UTC 2010-11-02 22:09:48
-- platform        : linux2
-- python version  : 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) 
--                   [GCC 4.4.5]
-- streams version : 0.1


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is

end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;

  signal CLK : std_logic;
  signal RST : std_logic;
  signal STATE_284      : BINARY_STATE_TYPE;
  signal STREAM_284     : std_logic_vector(0 downto 0);
  signal STREAM_284_STB : std_logic;
  signal STREAM_284_ACK : std_logic;

  signal STREAM_282     : std_logic_vector(4 downto 0);
  signal STREAM_282_STB : std_logic;
  signal STREAM_282_ACK : std_logic;
  signal STATE_282 : UNARY_STATE_TYPE;
  type LOOKUP_282_TYPE is array (0 to 127) of std_logic_vector(4 downto 0);
  signal LOOKUP_282 : LOOKUP_282_TYPE := (
0 => "11000",
1 => "10000",
2 => "10000",
3 => "10000",
4 => "10000",
5 => "10000",
6 => "10000",
7 => "10000",
8 => "11001",
9 => "10010",
10 => "10100",
11 => "11000",
12 => "10000",
13 => "10000",
14 => "10000",
15 => "10000",
16 => "11010",
17 => "10100",
18 => "11000",
19 => "10000",
20 => "10000",
21 => "10000",
22 => "10000",
23 => "10000",
24 => "11011",
25 => "10110",
26 => "11100",
27 => "11000",
28 => "10000",
29 => "10000",
30 => "10000",
31 => "10000",
32 => "11100",
33 => "11000",
34 => "10000",
35 => "10000",
36 => "10000",
37 => "10000",
38 => "10000",
39 => "10000",
40 => "11101",
41 => "11010",
42 => "10100",
43 => "11000",
44 => "10000",
45 => "10000",
46 => "10000",
47 => "10000",
48 => "11110",
49 => "11100",
50 => "11000",
51 => "10000",
52 => "10000",
53 => "10000",
54 => "10000",
55 => "10000",
56 => "11111",
57 => "11110",
58 => "11100",
59 => "11000",
60 => "10000",
61 => "10000",
62 => "10000",
63 => "10000",
64 => "10000",
65 => "10000",
66 => "10000",
67 => "10000",
68 => "10000",
69 => "10000",
70 => "10000",
71 => "10000",
72 => "10001",
73 => "10010",
74 => "10100",
75 => "11000",
76 => "00000",
77 => "00000",
78 => "00000",
79 => "00000",
80 => "10010",
81 => "10100",
82 => "11000",
83 => "00000",
84 => "00000",
85 => "00000",
86 => "00000",
87 => "00000",
88 => "10011",
89 => "10110",
90 => "11100",
91 => "01000",
92 => "00000",
93 => "00000",
94 => "00000",
95 => "00000",
96 => "10100",
97 => "11000",
98 => "00000",
99 => "00000",
100 => "00000",
101 => "00000",
102 => "00000",
103 => "00000",
104 => "10101",
105 => "11010",
106 => "00100",
107 => "01000",
108 => "00000",
109 => "00000",
110 => "00000",
111 => "00000",
112 => "10110",
113 => "11100",
114 => "01000",
115 => "00000",
116 => "00000",
117 => "00000",
118 => "00000",
119 => "00000",
120 => "10111",
121 => "11110",
122 => "01100",
123 => "01000",
124 => "00000",
125 => "00000",
126 => "00000",
127 => "00000"
  );

  signal STREAM_281     : std_logic_vector(7 downto 0);
  signal STREAM_281_STB : std_logic;
  signal STREAM_281_ACK : std_logic;

  signal STATE_283      : BINARY_STATE_TYPE;
  signal STREAM_283     : std_logic_vector(3 downto 0);
  signal STREAM_283_STB : std_logic;
  signal STREAM_283_ACK : std_logic;

  signal STREAM_278     : std_logic_vector(3 downto 0);
  signal STREAM_278_STB : std_logic;
  signal STREAM_278_ACK : std_logic;
  signal STATE_278 : UNARY_STATE_TYPE;
  type LOOKUP_278_TYPE is array (0 to 127) of std_logic_vector(3 downto 0);
  signal LOOKUP_278 : LOOKUP_278_TYPE := (
0 => "1000",
1 => "1000",
2 => "1000",
3 => "1000",
4 => "1000",
5 => "1000",
6 => "1000",
7 => "1000",
8 => "1001",
9 => "1001",
10 => "1001",
11 => "1001",
12 => "1001",
13 => "1001",
14 => "1001",
15 => "1001",
16 => "1010",
17 => "1010",
18 => "1010",
19 => "1010",
20 => "1010",
21 => "1010",
22 => "1010",
23 => "1010",
24 => "1011",
25 => "1011",
26 => "1011",
27 => "1011",
28 => "1011",
29 => "1011",
30 => "1011",
31 => "1011",
32 => "1100",
33 => "1100",
34 => "1100",
35 => "1100",
36 => "1100",
37 => "1100",
38 => "1100",
39 => "1100",
40 => "1101",
41 => "1101",
42 => "1101",
43 => "1101",
44 => "1101",
45 => "1101",
46 => "1101",
47 => "1101",
48 => "1110",
49 => "1110",
50 => "1110",
51 => "1110",
52 => "1110",
53 => "1110",
54 => "1110",
55 => "1110",
56 => "1111",
57 => "1111",
58 => "1111",
59 => "1111",
60 => "1111",
61 => "1111",
62 => "1111",
63 => "1111",
64 => "0000",
65 => "0000",
66 => "0000",
67 => "0000",
68 => "0000",
69 => "0000",
70 => "0000",
71 => "0000",
72 => "0001",
73 => "0001",
74 => "0001",
75 => "0001",
76 => "0001",
77 => "0001",
78 => "0001",
79 => "0001",
80 => "0010",
81 => "0010",
82 => "0010",
83 => "0010",
84 => "0010",
85 => "0010",
86 => "0010",
87 => "0010",
88 => "0011",
89 => "0011",
90 => "0011",
91 => "0011",
92 => "0011",
93 => "0011",
94 => "0011",
95 => "0011",
96 => "0100",
97 => "0100",
98 => "0100",
99 => "0100",
100 => "0100",
101 => "0100",
102 => "0100",
103 => "0100",
104 => "0101",
105 => "0101",
106 => "0101",
107 => "0101",
108 => "0101",
109 => "0101",
110 => "0101",
111 => "0101",
112 => "0110",
113 => "0110",
114 => "0110",
115 => "0110",
116 => "0110",
117 => "0110",
118 => "0110",
119 => "0110",
120 => "0111",
121 => "0111",
122 => "0111",
123 => "0111",
124 => "0111",
125 => "0111",
126 => "0111",
127 => "0111"
  );

  signal STREAM_277     : std_logic_vector(7 downto 0);
  signal STREAM_277_STB : std_logic;
  signal STREAM_277_ACK : std_logic;

  signal STREAM_280     : std_logic_vector(3 downto 0);
  signal STREAM_280_STB : std_logic;
  signal STREAM_280_ACK : std_logic;
  signal STATE_280 : UNARY_STATE_TYPE;
  type LOOKUP_280_TYPE is array (0 to 127) of std_logic_vector(3 downto 0);
  signal LOOKUP_280 : LOOKUP_280_TYPE := (
0 => "0000",
1 => "0001",
2 => "0010",
3 => "0011",
4 => "0100",
5 => "0101",
6 => "0110",
7 => "0111",
8 => "0000",
9 => "0001",
10 => "0010",
11 => "0011",
12 => "0100",
13 => "0101",
14 => "0110",
15 => "0111",
16 => "0000",
17 => "0001",
18 => "0010",
19 => "0011",
20 => "0100",
21 => "0101",
22 => "0110",
23 => "0111",
24 => "0000",
25 => "0001",
26 => "0010",
27 => "0011",
28 => "0100",
29 => "0101",
30 => "0110",
31 => "0111",
32 => "0000",
33 => "0001",
34 => "0010",
35 => "0011",
36 => "0100",
37 => "0101",
38 => "0110",
39 => "0111",
40 => "0000",
41 => "0001",
42 => "0010",
43 => "0011",
44 => "0100",
45 => "0101",
46 => "0110",
47 => "0111",
48 => "0000",
49 => "0001",
50 => "0010",
51 => "0011",
52 => "0100",
53 => "0101",
54 => "0110",
55 => "0111",
56 => "0000",
57 => "0001",
58 => "0010",
59 => "0011",
60 => "0100",
61 => "0101",
62 => "0110",
63 => "0111",
64 => "0000",
65 => "0001",
66 => "0010",
67 => "0011",
68 => "0100",
69 => "0101",
70 => "0110",
71 => "0111",
72 => "0000",
73 => "0001",
74 => "0010",
75 => "0011",
76 => "0100",
77 => "0101",
78 => "0110",
79 => "0111",
80 => "0000",
81 => "0001",
82 => "0010",
83 => "0011",
84 => "0100",
85 => "0101",
86 => "0110",
87 => "0111",
88 => "0000",
89 => "0001",
90 => "0010",
91 => "0011",
92 => "0100",
93 => "0101",
94 => "0110",
95 => "0111",
96 => "0000",
97 => "0001",
98 => "0010",
99 => "0011",
100 => "0100",
101 => "0101",
102 => "0110",
103 => "0111",
104 => "0000",
105 => "0001",
106 => "0010",
107 => "0011",
108 => "0100",
109 => "0101",
110 => "0110",
111 => "0111",
112 => "0000",
113 => "0001",
114 => "0010",
115 => "0011",
116 => "0100",
117 => "0101",
118 => "0110",
119 => "0111",
120 => "0000",
121 => "0001",
122 => "0010",
123 => "0011",
124 => "0100",
125 => "0101",
126 => "0110",
127 => "0111"
  );

  signal STREAM_279     : std_logic_vector(7 downto 0);
  signal STREAM_279_STB : std_logic;
  signal STREAM_279_ACK : std_logic;


begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
    end if;
  end process;

  --internal clock generator
  process
  begin
    while True loop
      CLK <= '0';
      wait for 5 ns;
      CLK <= '1';
      wait for 5 ns;
    end loop;
    wait;
  end process;

  --internal reset generator
  process
  begin
    RST <= '1';
    wait for 20 ns;
    RST <= '0';
    wait;
  end process;

  --file: ./test_streams_VHDL.py, line: 766
  --Asserter(284)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_284_ACK <= '0';
    if STREAM_284_STB = '1' and STREAM_284_ACK = '0' then
      assert(STREAM_284 /= "0") severity failure;
      STREAM_284_ACK <= '1';
    end if;
  end process;

  --file: /home/jon/streams/streams/streams.py, line: 114
  --STREAM 284 Binary(282, 283, 'eq')
  process
  begin
    wait until rising_edge(CLK);
    case STATE_284 is
      when BINARY_INPUT =>
        if STREAM_282_STB = '1' and STREAM_283_STB = '1' then
          STREAM_282_ACK <= '1'; STREAM_283_ACK <= '1';
          STREAM_284 <= EQ(  STREAM_282, STREAM_283);
          STREAM_284_STB <= '1';
          STATE_284 <= BINARY_OUTPUT;
        end if;
      when BINARY_OUTPUT =>
        STREAM_282_ACK <= '0'; STREAM_283_ACK <= '0';
        if STREAM_284_ACK = '1' then
           STREAM_284_STB <= '0';
           STATE_284 <= BINARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_284_STB <= '0';
       STREAM_282_ACK <= '0';
       STREAM_283_ACK <= '0';
       STATE_284 <= BINARY_INPUT;
     end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 282 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_282 is
      when UNARY_INPUT =>
        if STREAM_281_STB = '1' then
          STREAM_281_ACK <= '1';
          STREAM_282_STB <= '1';
          STREAM_282 <= LOOKUP_282(to_integer(unsigned(STREAM_281)));
          STATE_282 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_281_ACK <= '0';
        if STREAM_282_ACK = '1' then
           STREAM_282_STB <= '0';
           STATE_282 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_282_STB <= '0';
       STREAM_281_ACK <= '0';
       STATE_282 <= UNARY_INPUT;
     end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 281 Counter(0, 127, 1, 8)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_281_STB <= '1';
    if STREAM_281_ACK = '1' then
      STREAM_281_STB <= '0';
      STREAM_281 <= STD_RESIZE(ADD(STREAM_281, "00000001"), 8);
      if STREAM_281 = "01111111" then
        STREAM_281 <= "00000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_281_STB <= '0';
      STREAM_281 <= "00000000";
    end if;
  end process;

  --file: /home/jon/streams/streams/streams.py, line: 113
  --STREAM 283 Binary(278, 280, 'sl')
  process
  begin
    wait until rising_edge(CLK);
    case STATE_283 is
      when BINARY_INPUT =>
        if STREAM_278_STB = '1' and STREAM_280_STB = '1' then
          STREAM_278_ACK <= '1'; STREAM_280_ACK <= '1';
          STREAM_283 <= SL(  STREAM_278, STREAM_280);
          STREAM_283_STB <= '1';
          STATE_283 <= BINARY_OUTPUT;
        end if;
      when BINARY_OUTPUT =>
        STREAM_278_ACK <= '0'; STREAM_280_ACK <= '0';
        if STREAM_283_ACK = '1' then
           STREAM_283_STB <= '0';
           STATE_283 <= BINARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_283_STB <= '0';
       STREAM_278_ACK <= '0';
       STREAM_280_ACK <= '0';
       STATE_283 <= BINARY_INPUT;
     end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 278 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_278 is
      when UNARY_INPUT =>
        if STREAM_277_STB = '1' then
          STREAM_277_ACK <= '1';
          STREAM_278_STB <= '1';
          STREAM_278 <= LOOKUP_278(to_integer(unsigned(STREAM_277)));
          STATE_278 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_277_ACK <= '0';
        if STREAM_278_ACK = '1' then
           STREAM_278_STB <= '0';
           STATE_278 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_278_STB <= '0';
       STREAM_277_ACK <= '0';
       STATE_278 <= UNARY_INPUT;
     end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 277 Counter(0, 127, 1, 8)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_277_STB <= '1';
    if STREAM_277_ACK = '1' then
      STREAM_277_STB <= '0';
      STREAM_277 <= STD_RESIZE(ADD(STREAM_277, "00000001"), 8);
      if STREAM_277 = "01111111" then
        STREAM_277 <= "00000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_277_STB <= '0';
      STREAM_277 <= "00000000";
    end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 280 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_280 is
      when UNARY_INPUT =>
        if STREAM_279_STB = '1' then
          STREAM_279_ACK <= '1';
          STREAM_280_STB <= '1';
          STREAM_280 <= LOOKUP_280(to_integer(unsigned(STREAM_279)));
          STATE_280 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_279_ACK <= '0';
        if STREAM_280_ACK = '1' then
           STREAM_280_STB <= '0';
           STATE_280 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_280_STB <= '0';
       STREAM_279_ACK <= '0';
       STATE_280 <= UNARY_INPUT;
     end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 279 Counter(0, 127, 1, 8)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_279_STB <= '1';
    if STREAM_279_ACK = '1' then
      STREAM_279_STB <= '0';
      STREAM_279 <= STD_RESIZE(ADD(STREAM_279, "00000001"), 8);
      if STREAM_279 = "01111111" then
        STREAM_279 <= "00000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_279_STB <= '0';
      STREAM_279 <= "00000000";
    end if;
  end process;


end architecture RTL;