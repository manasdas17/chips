-- generated by python streams library
-- date generated  : UTC 2010-11-01 20:58:31
-- platform        : linux2
-- python version  : 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) 
--                   [GCC 4.4.5]
-- streams version : 0.1


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is

end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;

  signal CLK : std_logic;
  signal RST : std_logic;
  signal STREAM_1     : std_logic_vector(10 downto 0);
  signal STREAM_1_STB : std_logic;
  signal STREAM_1_ACK : std_logic;
  signal STATE_1 : UNARY_STATE_TYPE;
  type LOOKUP_1_TYPE is array (0 to 99) of std_logic_vector(10 downto 0);
  signal LOOKUP_1 : LOOKUP_1_TYPE := (
0 => "00000000000",
1 => "00000001000",
2 => "00000010000",
3 => "00000011000",
4 => "00000100000",
5 => "00000101000",
6 => "00000110000",
7 => "00000111000",
8 => "00001000000",
9 => "00001001001",
10 => "00001010001",
11 => "00001011001",
12 => "00001100001",
13 => "00001101001",
14 => "00001110001",
15 => "00001111001",
16 => "00010000001",
17 => "00010001010",
18 => "00010010010",
19 => "00010011010",
20 => "00010100010",
21 => "00010101010",
22 => "00010110010",
23 => "00010111010",
24 => "00011000010",
25 => "00011001011",
26 => "00011010011",
27 => "00011011011",
28 => "00011100011",
29 => "00011101011",
30 => "00011110011",
31 => "00011111011",
32 => "00100000011",
33 => "00100001100",
34 => "00100010100",
35 => "00100011100",
36 => "00100100100",
37 => "00100101100",
38 => "00100110100",
39 => "00100111100",
40 => "00101000100",
41 => "00101001100",
42 => "00101010101",
43 => "00101011101",
44 => "00101100101",
45 => "00101101101",
46 => "00101110101",
47 => "00101111101",
48 => "00110000101",
49 => "00110001101",
50 => "00110010110",
51 => "00110011110",
52 => "00110100110",
53 => "00110101110",
54 => "00110110110",
55 => "00110111110",
56 => "00111000110",
57 => "00111001110",
58 => "00111010111",
59 => "00111011111",
60 => "00111100111",
61 => "00111101111",
62 => "00111110111",
63 => "00111111111",
64 => "01000000111",
65 => "01000001111",
66 => "01000011000",
67 => "01000100000",
68 => "01000101000",
69 => "01000110000",
70 => "01000111000",
71 => "01001000000",
72 => "01001001000",
73 => "01001010000",
74 => "01001011000",
75 => "01001100001",
76 => "01001101001",
77 => "01001110001",
78 => "01001111001",
79 => "01010000001",
80 => "01010001001",
81 => "01010010001",
82 => "01010011001",
83 => "01010100010",
84 => "01010101010",
85 => "01010110010",
86 => "01010111010",
87 => "01011000010",
88 => "01011001010",
89 => "01011010010",
90 => "01011011010",
91 => "01011100011",
92 => "01011101011",
93 => "01011110011",
94 => "01011111011",
95 => "01100000011",
96 => "01100001011",
97 => "01100010011",
98 => "01100011011",
99 => "01100100100"
  );

  signal STREAM_0     : std_logic_vector(7 downto 0);
  signal STREAM_0_STB : std_logic;
  signal STREAM_0_ACK : std_logic;

  signal STREAM_2       : std_logic_vector(31 downto 0);
  signal STREAM_2_STB   : std_logic;
  signal STREAM_2_ACK   : std_logic;
  constant OP_ADD_3 : std_logic_vector(4 downto 0) := "00000";
  constant OP_SUB_3 : std_logic_vector(4 downto 0) := "00001";
  constant OP_MUL_3 : std_logic_vector(4 downto 0) := "00010";
  constant OP_DIV_3 : std_logic_vector(4 downto 0) := "00011";
  constant OP_BAND_3 : std_logic_vector(4 downto 0) := "00100";
  constant OP_BOR_3 : std_logic_vector(4 downto 0) := "00101";
  constant OP_BXOR_3 : std_logic_vector(4 downto 0) := "00110";
  constant OP_SL_3 : std_logic_vector(4 downto 0) := "00111";
  constant OP_SR_3 : std_logic_vector(4 downto 0) := "01000";
  constant OP_EQ_3 : std_logic_vector(4 downto 0) := "01001";
  constant OP_NE_3 : std_logic_vector(4 downto 0) := "01010";
  constant OP_GT_3 : std_logic_vector(4 downto 0) := "01011";
  constant OP_GE_3 : std_logic_vector(4 downto 0) := "01100";
  constant OP_JMP_3 : std_logic_vector(4 downto 0) := "01101";
  constant OP_JMPF_3 : std_logic_vector(4 downto 0) := "01110";
  constant OP_IMM_3 : std_logic_vector(4 downto 0) := "01111";
  constant OP_MOVE_3 : std_logic_vector(4 downto 0) := "10000";
  constant OP_WAIT_US_3 : std_logic_vector(4 downto 0) := "10001";
  constant OP_MOD_3 : std_logic_vector(4 downto 0) := "10010";
  constant OP_READ_1_3 : std_logic_vector(4 downto 0) := "10011";
  constant OP_WRITE_2_3 : std_logic_vector(4 downto 0) := "10100";
  type PROCESS_3_STATE_TYPE is (STALL, EXECUTE, DIVIDE_0, DIVIDE_1, DIVIDE_2, WAIT_US, READ_STREAM_1, ACK_STREAM_1, WRITE_STREAM_2);
  type INSTRUCTIONS_TYPE_3  is array (0 to 87) of std_logic_vector(40 downto 0);
  type REGISTERS_TYPE_3     is array (0 to 15) of std_logic_vector(31 downto 0);
  signal STATE_3        : PROCESS_3_STATE_TYPE;
  signal REGISTERS_3    : REGISTERS_TYPE_3;
  signal PC_3           : unsigned(6 downto 0);
  signal OPERATION_3    : std_logic_vector(4 downto 0);
  signal SRCA_3         : std_logic_vector(3 downto 0);
  signal SRCB_3         : std_logic_vector(3 downto 0);
  signal IMMEDIATE_3    : std_logic_vector(31 downto 0);
  signal ZERO_3         : std_logic;
  signal A_3            : std_logic_vector(31 downto 0);
  signal B_3            : std_logic_vector(31 downto 0);
  signal QUOTIENT_3     : std_logic_vector(31 downto 0);
  signal SHIFTER_3      : std_logic_vector(31 downto 0);
  signal REMAINDER_3    : std_logic_vector(31 downto 0);
  signal COUNT_3        : integer range 0 to 32;
  signal SIGN_3         : std_logic;
  signal INSTRUCTIONS_3 : INSTRUCTIONS_TYPE_3 := (
0 => OP_IMM_3 & "0001" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 24
1 => OP_IMM_3 & "0010" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 19
2 => OP_IMM_3 & "0011" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 20
3 => OP_IMM_3 & "0100" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 25
4 => OP_IMM_3 & "0101" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 23
5 => OP_IMM_3 & "0110" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 21
6 => OP_IMM_3 & "0111" & "00000000000000000000000000000000", -- file: ./example_2_taylor_series.py line: 22
7 => OP_READ_1_3 & "0001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 137
8 => OP_MOVE_3 & "1000" & "00000000000000000000000000000001", -- file: ./example_2_taylor_series.py line: 24
9 => OP_MOVE_3 & "0010" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
10 => OP_IMM_3 & "1000" & "00000000000000000000000000000011", -- file: /home/jon/streams/streams/instruction.py line: 109
11 => OP_MOVE_3 & "0011" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
12 => OP_IMM_3 & "1000" & "11111111111111111111111111111111", -- file: /home/jon/streams/streams/instruction.py line: 109
13 => OP_MOVE_3 & "0100" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
14 => OP_IMM_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 109
15 => OP_MOVE_3 & "1001" & "00000000000000000000000000000011", -- file: ./example_2_taylor_series.py line: 20
16 => OP_GE_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 129
17 => OP_IMM_3 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/instruction.py line: 109
18 => OP_EQ_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 124
19 => OP_JMPF_3 & "1000" & "00000000000000000000000000010110", -- file: None line: None
20 => OP_JMP_3 & "0000" & "00000000000000000000000001010011", -- file: /home/jon/streams/streams/__init__.py line: 58
21 => OP_JMP_3 & "0000" & "00000000000000000000000000010110", -- file: None line: None
22 => OP_IMM_3 & "1000" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/instruction.py line: 109
23 => OP_MOVE_3 & "0101" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
24 => OP_IMM_3 & "1000" & "00000000000000000000000100000000", -- file: /home/jon/streams/streams/instruction.py line: 109
25 => OP_MOVE_3 & "0110" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
26 => OP_MOVE_3 & "1000" & "00000000000000000000000000000011", -- file: ./example_2_taylor_series.py line: 20
27 => OP_MOVE_3 & "1001" & "00000000000000000000000000000101", -- file: ./example_2_taylor_series.py line: 23
28 => OP_GT_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 128
29 => OP_IMM_3 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/instruction.py line: 109
30 => OP_EQ_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 124
31 => OP_JMPF_3 & "1000" & "00000000000000000000000000100010", -- file: None line: None
32 => OP_JMP_3 & "0000" & "00000000000000000000000000101101", -- file: /home/jon/streams/streams/__init__.py line: 58
33 => OP_JMP_3 & "0000" & "00000000000000000000000000100010", -- file: None line: None
34 => OP_MOVE_3 & "1000" & "00000000000000000000000000000110", -- file: ./example_2_taylor_series.py line: 21
35 => OP_MOVE_3 & "1001" & "00000000000000000000000000000001", -- file: ./example_2_taylor_series.py line: 24
36 => OP_MUL_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 116
37 => OP_IMM_3 & "1001" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 109
38 => OP_SR_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 122
39 => OP_MOVE_3 & "0110" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
40 => OP_MOVE_3 & "1000" & "00000000000000000000000000000101", -- file: ./example_2_taylor_series.py line: 23
41 => OP_IMM_3 & "1001" & "00000000000000000000000000000001", -- file: /home/jon/streams/streams/instruction.py line: 109
42 => OP_ADD_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 114
43 => OP_MOVE_3 & "0101" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
44 => OP_JMP_3 & "0000" & "00000000000000000000000000011010", -- file: /home/jon/streams/streams/__init__.py line: 59
45 => OP_IMM_3 & "1000" & "00000000000000000000000000000001", -- file: /home/jon/streams/streams/instruction.py line: 109
46 => OP_MOVE_3 & "0101" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
47 => OP_IMM_3 & "1000" & "00000000000000000000000000000001", -- file: /home/jon/streams/streams/instruction.py line: 109
48 => OP_MOVE_3 & "0111" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
49 => OP_MOVE_3 & "1000" & "00000000000000000000000000000011", -- file: ./example_2_taylor_series.py line: 20
50 => OP_MOVE_3 & "1001" & "00000000000000000000000000000101", -- file: ./example_2_taylor_series.py line: 23
51 => OP_GE_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 129
52 => OP_IMM_3 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/instruction.py line: 109
53 => OP_EQ_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 124
54 => OP_JMPF_3 & "1000" & "00000000000000000000000000111001", -- file: None line: None
55 => OP_JMP_3 & "0000" & "00000000000000000000000001000010", -- file: /home/jon/streams/streams/__init__.py line: 58
56 => OP_JMP_3 & "0000" & "00000000000000000000000000111001", -- file: None line: None
57 => OP_MOVE_3 & "1000" & "00000000000000000000000000000111", -- file: ./example_2_taylor_series.py line: 22
58 => OP_MOVE_3 & "1001" & "00000000000000000000000000000101", -- file: ./example_2_taylor_series.py line: 23
59 => OP_MUL_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 116
60 => OP_MOVE_3 & "0111" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
61 => OP_MOVE_3 & "1000" & "00000000000000000000000000000101", -- file: ./example_2_taylor_series.py line: 23
62 => OP_IMM_3 & "1001" & "00000000000000000000000000000001", -- file: /home/jon/streams/streams/instruction.py line: 109
63 => OP_ADD_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 114
64 => OP_MOVE_3 & "0101" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
65 => OP_JMP_3 & "0000" & "00000000000000000000000000110001", -- file: /home/jon/streams/streams/__init__.py line: 59
66 => OP_MOVE_3 & "1000" & "00000000000000000000000000000010", -- file: ./example_2_taylor_series.py line: 19
67 => OP_MOVE_3 & "1001" & "00000000000000000000000000000100", -- file: ./example_2_taylor_series.py line: 25
68 => OP_MOVE_3 & "1010" & "00000000000000000000000000000110", -- file: ./example_2_taylor_series.py line: 21
69 => OP_MOVE_3 & "1011" & "00000000000000000000000000000111", -- file: ./example_2_taylor_series.py line: 22
70 => OP_DIV_3 & "1010" & "00000000000000000000000000001011", -- file: /home/jon/streams/streams/instruction.py line: 118
71 => OP_MUL_3 & "1001" & "00000000000000000000000000001010", -- file: /home/jon/streams/streams/instruction.py line: 116
72 => OP_ADD_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 114
73 => OP_MOVE_3 & "0010" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
74 => OP_IMM_3 & "1000" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/instruction.py line: 109
75 => OP_MOVE_3 & "1001" & "00000000000000000000000000000100", -- file: ./example_2_taylor_series.py line: 25
76 => OP_SUB_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 131
77 => OP_MOVE_3 & "0100" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
78 => OP_MOVE_3 & "1000" & "00000000000000000000000000000011", -- file: ./example_2_taylor_series.py line: 20
79 => OP_IMM_3 & "1001" & "00000000000000000000000000000010", -- file: /home/jon/streams/streams/instruction.py line: 109
80 => OP_ADD_3 & "1000" & "00000000000000000000000000001001", -- file: /home/jon/streams/streams/instruction.py line: 114
81 => OP_MOVE_3 & "0011" & "00000000000000000000000000001000", -- file: /home/jon/streams/streams/instruction.py line: 264
82 => OP_JMP_3 & "0000" & "00000000000000000000000000001110", -- file: /home/jon/streams/streams/__init__.py line: 59
83 => OP_MOVE_3 & "1000" & "00000000000000000000000000000010", -- file: ./example_2_taylor_series.py line: 19
84 => OP_WRITE_2_3 & "1000" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 312
85 => OP_JMP_3 & "0000" & "00000000000000000000000000000111", -- file: ./example_2_taylor_series.py line: 52
86 => OP_JMP_3 & "0000" & "00000000000000000000000001010110", -- file: None line: None
87 => OP_JMP_3 & "0000" & "00000000000000000000000000000000"); -- file: None line: None
  signal MOD_DIV_3      : std_logic;

begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
    end if;
  end process;

  --internal clock generator
  process
  begin
    while True loop
      CLK <= '0';
      wait for 5 ns;
      CLK <= '1';
      wait for 5 ns;
    end loop;
    wait;
  end process;

  --internal reset generator
  process
  begin
    RST <= '1';
    wait for 20 ns;
    RST <= '0';
    wait;
  end process;

  --file: ./example_2_taylor_series.py, line: 76
  --OutPort(2, 32)
  process
    file OUTFILE : text open write_mode is "resp_2.txt";
    variable OUTLINE : LINE;
    variable VALUE : integer;
  begin
    wait until rising_edge(CLK);
    STREAM_2_ACK <= '0';
    if STREAM_2_STB = '1' then
      STREAM_2_ACK <= '1';
    end if;    if STREAM_2_STB = '1' and STREAM_2_ACK = '1' then
      VALUE := to_integer(signed(STREAM_2));
      write(OUTLINE, VALUE);
      writeline(OUTFILE, OUTLINE);
    end if;  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 1 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_1 is
      when UNARY_INPUT =>
        if STREAM_0_STB = '1' then
          STREAM_0_ACK <= '1';
          STREAM_1_STB <= '1';
          STREAM_1 <= LOOKUP_1(to_integer(unsigned(STREAM_0)));
          STATE_1 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_0_ACK <= '0';
        if STREAM_1_ACK = '1' then
           STREAM_1_STB <= '0';
           STATE_1 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_1_STB <= '0';
       STREAM_0_ACK <= '0';
       STATE_1 <= UNARY_INPUT;
     end if;
  end process;

  --file: /home/jon/streams/streams/__init__.py, line: 54
  --STREAM 0 Counter(0, 99, 1, 8)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_0_STB <= '1';
    if STREAM_0_ACK = '1' then
      STREAM_0_STB <= '0';
      STREAM_0 <= STD_RESIZE(ADD(STREAM_0, "00000001"), 8);
      if STREAM_0 = "01100011" then
        STREAM_0 <= "00000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_0_STB <= '0';
      STREAM_0 <= "00000000";
    end if;
  end process;

  -- process
  process
    variable INSTRUCTION : std_logic_vector(40 downto 0);
  begin
    wait until rising_edge(CLK);
    INSTRUCTION := INSTRUCTIONS_3(to_integer(PC_3));
    OPERATION_3 <= INSTRUCTION(40 downto 36);
    SRCA_3      <= INSTRUCTION(35 downto 32);
    SRCB_3      <= INSTRUCTION(3 downto 0);
    IMMEDIATE_3 <= INSTRUCTION(31 downto 0);
  end process;

  process
    variable REGA    : std_logic_vector(31 downto 0);
    variable REGB    : std_logic_vector(31 downto 0);
    variable DEST    : std_logic_vector(3 downto 0);
    variable RESULT  : std_logic_vector(31 downto 0);
    variable REGISTERS_EN  : std_logic;
    variable MODULO  : unsigned(31 downto 0);
    variable FLAG_EQ : std_logic;
    variable FLAG_NE : std_logic;
    variable FLAG_GT : std_logic;
    variable FLAG_GE : std_logic;
  begin
    wait until rising_edge(CLK);
    REGISTERS_EN := '0';
    case STATE_3 is
      when STALL =>
        PC_3 <= PC_3 + 1;
        STATE_3 <= EXECUTE;
      when EXECUTE =>
        REGA := REGISTERS_3(to_integer(unsigned(SRCA_3)));
        REGB := REGISTERS_3(to_integer(unsigned(SRCB_3)));
        DEST := SRCA_3;
        RESULT := REGA;
        PC_3 <= PC_3 + 1;

        --share comparator logic
        if REGA = REGB then
          FLAG_EQ := '1';
        else
          FLAG_EQ := '0';
        end if;

        if signed(REGA) > signed(REGB) then
          FLAG_GT := '1';
        else
          FLAG_GT := '0';
        end if;

        FLAG_NE := not FLAG_EQ;
        FLAG_GE := FLAG_GT or FLAG_EQ;

        --execute instructions
        case OPERATION_3 is
          when OP_MOVE_3 => 
            RESULT := REGB;
            REGISTERS_EN := '1';
          when OP_MUL_3  => 
            RESULT := STD_RESIZE( MUL(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_ADD_3  => 
            RESULT := STD_RESIZE( ADD(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_SUB_3  => 
            RESULT := STD_RESIZE( SUB(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_BAND_3 => 
            RESULT := STD_RESIZE(BAND(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_BOR_3  => 
            RESULT := STD_RESIZE( BOR(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_BXOR_3 => 
            RESULT := STD_RESIZE(BXOR(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_SL_3   => 
            RESULT := STD_RESIZE(  SL(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_SR_3   => 
            RESULT := STD_RESIZE(  SR(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_EQ_3   => 
            RESULT := (others => FLAG_EQ);
            REGISTERS_EN := '1';
          when OP_NE_3   => 
            RESULT := (others => FLAG_NE);
            REGISTERS_EN := '1';
          when OP_GT_3   => 
            RESULT := (others => FLAG_GT);
            REGISTERS_EN := '1';
          when OP_GE_3   => 
            RESULT := (others => FLAG_GE);
            REGISTERS_EN := '1';
          when OP_IMM_3  => 
            RESULT := IMMEDIATE_3;
            REGISTERS_EN := '1';
          when OP_JMP_3 =>
            STATE_3 <= STALL;
            PC_3 <= resize(unsigned(IMMEDIATE_3), 7);
          when OP_JMPF_3 =>
            if ZERO_3 = '1' then
              STATE_3 <= STALL;
              PC_3 <= resize(unsigned(IMMEDIATE_3), 7);
            end if;
          when OP_WAIT_US_3 =>
            STATE_3 <= WAIT_US;
            PC_3 <= PC_3;
          when OP_DIV_3 =>
            MOD_DIV_3 <= '1';
            A_3 <= std_logic_vector(abs(signed(REGA)));
            B_3 <= std_logic_vector(abs(signed(REGB)));
            SIGN_3 <= REGA(31) xor REGB(31);
            STATE_3 <= DIVIDE_0;
            PC_3 <= PC_3;
          when OP_MOD_3 =>
            MOD_DIV_3 <= '0';
            A_3 <= std_logic_vector(abs(signed(REGA)));
            B_3 <= std_logic_vector(abs(signed(REGB)));
            SIGN_3 <= REGA(31);
            STATE_3 <= DIVIDE_0;
            PC_3 <= PC_3;
          when OP_WRITE_2_3 =>
            STATE_3 <= WRITE_STREAM_2;
            DEST := SRCA_3;
            PC_3 <= PC_3;
          when OP_READ_1_3 =>
            STATE_3 <= READ_STREAM_1;
            PC_3 <= PC_3;
          when others => null;
        end case;

        --write back results
        if RESULT = "00000000000000000000000000000000" then
          ZERO_3 <= '1';
        else
          ZERO_3 <= '0';
        end if;

      when DIVIDE_0 =>
        QUOTIENT_3 <= (others => '0');
        SHIFTER_3 <= (others => '0');
        SHIFTER_3(0) <= A_3(31);
        A_3 <= A_3(30 downto 0) & '0';
        COUNT_3 <= 31;
        STATE_3 <= DIVIDE_1;

      when DIVIDE_1 => --subtract
       --if SHIFTER - B is positive or zero
       if REMAINDER_3(31) = '0' then
         SHIFTER_3(31 downto 1) <= REMAINDER_3(30 downto 0);
       else
         SHIFTER_3(31 downto 1) <= SHIFTER_3(30 downto 0);
       end if;
       SHIFTER_3(0) <= A_3(31);
       A_3 <= A_3(30 downto 0) & '0';
       QUOTIENT_3 <= QUOTIENT_3(30 downto 0) & not(REMAINDER_3(31));
       if COUNT_3 = 0 then
         STATE_3 <= DIVIDE_2;
       else
         COUNT_3 <= COUNT_3 - 1;
       end if;

     when DIVIDE_2 =>
      REGISTERS_EN := '1';
      if MOD_DIV_3 = '1' then --if division
        if SIGN_3 = '1' then --if negative
          RESULT := std_logic_vector(-signed(QUOTIENT_3));
        else
          RESULT := QUOTIENT_3;
        end if;
      else
        MODULO := unsigned(SHIFTER_3)/2;
        if SIGN_3 = '1' then --if negative
          RESULT := std_logic_vector(0-MODULO);
        else
          RESULT := std_logic_vector(  MODULO);
        end if;
      end if;
      STATE_3 <= EXECUTE;
      PC_3 <= PC_3 + 1;
      when READ_STREAM_1 =>
        if STREAM_1_STB = '1' then
          STREAM_1_ACK <= '1';
          REGISTERS_EN := '1';
          RESULT := STD_RESIZE(STREAM_1, 32);
          STATE_3 <= ACK_STREAM_1;
        end if;
      when ACK_STREAM_1 =>
        STREAM_1_ACK <= '0';
        STATE_3 <= EXECUTE;
        PC_3 <= PC_3 + 1;
      when WRITE_STREAM_2 =>
        STREAM_2_STB <= '1';
        STREAM_2 <= STD_RESIZE(REGA, 32);
        if STREAM_2_ACK = '1' then
          STREAM_2_STB <= '0';
          STATE_3 <= EXECUTE;
          PC_3 <= PC_3 + 1;
        end if;
      when WAIT_US =>
        if TIMER_1uS = '1'then
          PC_3 <= PC_3 + 1;
          STATE_3 <= EXECUTE;
        end if;
    end case;

    if RST = '1' then
      STATE_3 <= STALL;
      PC_3 <= "0000000";
      STREAM_1_ACK <= '0';
      STREAM_2_STB <= '0';
    end if;
    if REGISTERS_EN = '1' then
      REGISTERS_3(to_integer(unsigned(DEST))) <= RESULT;
    end if;
  end process;


  --subtractor
  REMAINDER_3 <= std_logic_vector(unsigned(SHIFTER_3) - resize(unsigned(B_3), 32));

end architecture RTL;