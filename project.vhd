-- generated by python streams library
-- date generated  : UTC 2010-11-11 21:45:57
-- platform        : linux2
-- python version  : 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) 
--                   [GCC 4.4.5]
-- streams version : 0.1


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is
  port(
    CLK           : in  std_logic;
    RST           : in  std_logic;
    TX : out std_logic;
    RX : in std_logic
  );
end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;



  signal STATE_4           : SERIAL_OUT_STATE_TYPE;
  constant CLOCK_DIVIDER_4 : Unsigned(11 downto 0) := To_unsigned(433, 12);
  signal BAUD_COUNT_4      : Unsigned(11 downto 0);
  signal DATA_4            : std_logic_vector(7 downto 0);
  signal X16CLK_EN_4       : std_logic;
  signal STREAM_3     : std_logic_vector(7 downto 0);
  signal STREAM_3_STB : std_logic;
  signal STREAM_3_ACK : std_logic;

  signal STATE_0           : SERIAL_IN_STATE_TYPE;
  signal STREAM_0          : std_logic_vector(7 downto 0);
  signal STREAM_0_STB      : std_logic;
  signal STREAM_0_ACK      : std_logic;
  signal COUNT_0           : integer Range 0 to 3;
  signal BIT_SPACING_0     : integer Range 0 to 15;
  signal INT_SERIAL_0      : std_logic;
  signal SERIAL_DEGLITCH_0 : std_logic_Vector(1 downto 0);
  constant CLOCK_DIVIDER_0 : unsigned(11 downto 0) := To_unsigned(26, 12);
  signal BAUD_COUNT_0      : unsigned(11 downto 0);
  signal X16CLK_EN_0       : std_logic;
  signal STREAM_1       : std_logic_vector(31 downto 0);
  signal STREAM_1_STB   : std_logic;
  signal STREAM_1_ACK   : std_logic;
  constant OP_ADD_2 : std_logic_vector(4 downto 0) := "00000";
  constant OP_SUB_2 : std_logic_vector(4 downto 0) := "00001";
  constant OP_MUL_2 : std_logic_vector(4 downto 0) := "00010";
  constant OP_DIV_2 : std_logic_vector(4 downto 0) := "00011";
  constant OP_BAND_2 : std_logic_vector(4 downto 0) := "00100";
  constant OP_BOR_2 : std_logic_vector(4 downto 0) := "00101";
  constant OP_BXOR_2 : std_logic_vector(4 downto 0) := "00110";
  constant OP_SL_2 : std_logic_vector(4 downto 0) := "00111";
  constant OP_SR_2 : std_logic_vector(4 downto 0) := "01000";
  constant OP_EQ_2 : std_logic_vector(4 downto 0) := "01001";
  constant OP_NE_2 : std_logic_vector(4 downto 0) := "01010";
  constant OP_GT_2 : std_logic_vector(4 downto 0) := "01011";
  constant OP_GE_2 : std_logic_vector(4 downto 0) := "01100";
  constant OP_JMP_2 : std_logic_vector(4 downto 0) := "01101";
  constant OP_JMPF_2 : std_logic_vector(4 downto 0) := "01110";
  constant OP_IMM_2 : std_logic_vector(4 downto 0) := "01111";
  constant OP_MOVE_2 : std_logic_vector(4 downto 0) := "10000";
  constant OP_WAIT_US_2 : std_logic_vector(4 downto 0) := "10001";
  constant OP_MOD_2 : std_logic_vector(4 downto 0) := "10010";
  constant OP_READ_0_2 : std_logic_vector(4 downto 0) := "10011";
  constant OP_WRITE_1_2 : std_logic_vector(4 downto 0) := "10100";
  type PROCESS_2_STATE_TYPE is (STALL, EXECUTE, WAIT_US, READ_STREAM_0, ACK_STREAM_0, WRITE_STREAM_1);
  type INSTRUCTIONS_TYPE_2  is array (0 to 34) of std_logic_vector(40 downto 0);
  type REGISTERS_TYPE_2     is array (0 to 15) of std_logic_vector(31 downto 0);
  signal STATE_2        : PROCESS_2_STATE_TYPE;
  signal REGISTERS_2    : REGISTERS_TYPE_2;
  signal PC_2           : unsigned(5 downto 0);
  signal OPERATION_2    : std_logic_vector(4 downto 0);
  signal SRCA_2         : std_logic_vector(3 downto 0);
  signal SRCB_2         : std_logic_vector(3 downto 0);
  signal IMMEDIATE_2    : std_logic_vector(31 downto 0);
  signal ZERO_2         : std_logic;
  signal A_2            : std_logic_vector(31 downto 0);
  signal B_2            : std_logic_vector(31 downto 0);
  signal QUOTIENT_2     : std_logic_vector(31 downto 0);
  signal SHIFTER_2      : std_logic_vector(31 downto 0);
  signal REMAINDER_2    : std_logic_vector(31 downto 0);
  signal COUNT_2        : integer range 0 to 32;
  signal SIGN_2         : std_logic;
  signal INSTRUCTIONS_2 : INSTRUCTIONS_TYPE_2 := (
0 => OP_IMM_2 & "0001" & "00000000000000000000000000000000", -- file: ./size_test.py line: 15
1 => OP_IMM_2 & "0010" & "00000000000000000000000000000000", -- file: ./size_test.py line: 16
2 => OP_IMM_2 & "0011" & "00000000000000000000000000000000", -- file: ./size_test.py line: 17
3 => OP_IMM_2 & "0100" & "00000000000000000000000000000000", -- file: ./size_test.py line: 18
4 => OP_IMM_2 & "0101" & "00000000000000000000000000000000", -- file: ./size_test.py line: 19
5 => OP_IMM_2 & "0110" & "00000000000000000000000000000000", -- file: ./size_test.py line: 20
6 => OP_IMM_2 & "0111" & "00000000000000000000000000000000", -- file: ./size_test.py line: 21
7 => OP_IMM_2 & "1000" & "00000000000000000000000000000000", -- file: ./size_test.py line: 22
8 => OP_READ_0_2 & "0001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
9 => OP_MOVE_2 & "1001" & "00000000000000000000000000000001", -- file: ./size_test.py line: 15
10 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
11 => OP_READ_0_2 & "0010" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
12 => OP_MOVE_2 & "1001" & "00000000000000000000000000000010", -- file: ./size_test.py line: 16
13 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
14 => OP_READ_0_2 & "0011" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
15 => OP_MOVE_2 & "1001" & "00000000000000000000000000000011", -- file: ./size_test.py line: 17
16 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
17 => OP_READ_0_2 & "0100" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
18 => OP_MOVE_2 & "1001" & "00000000000000000000000000000100", -- file: ./size_test.py line: 18
19 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
20 => OP_READ_0_2 & "0101" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
21 => OP_MOVE_2 & "1001" & "00000000000000000000000000000101", -- file: ./size_test.py line: 19
22 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
23 => OP_READ_0_2 & "0110" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
24 => OP_MOVE_2 & "1001" & "00000000000000000000000000000110", -- file: ./size_test.py line: 20
25 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
26 => OP_READ_0_2 & "0111" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
27 => OP_MOVE_2 & "1001" & "00000000000000000000000000000111", -- file: ./size_test.py line: 21
28 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
29 => OP_READ_0_2 & "1000" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 148
30 => OP_MOVE_2 & "1001" & "00000000000000000000000000001000", -- file: ./size_test.py line: 22
31 => OP_WRITE_1_2 & "1001" & "00000000000000000000000000000000", -- file: /home/jon/streams/streams/streams.py line: 371
32 => OP_JMP_2 & "0000" & "00000000000000000000000000001000", -- file: ./size_test.py line: 45
33 => OP_JMP_2 & "0000" & "00000000000000000000000000100001", -- file: None line: None
34 => OP_JMP_2 & "0000" & "00000000000000000000000000000000"); -- file: None line: None
  signal MOD_DIV_2      : std_logic;

begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
    end if;
  end process;



  --file: ./size_test.py, line: 53
  --serial output port baud rate generator
  process
  begin
    wait until rising_edge(CLK);
    if BAUD_COUNT_4 = CLOCK_DIVIDER_4 then
      BAUD_COUNT_4 <= (others => '0');
      X16CLK_EN_4  <= '1';
    else
      BAUD_COUNT_4 <= BAUD_COUNT_4 + 1;
      X16CLK_EN_4  <= '0';
    end if;
    if RST = '1' then
      BAUD_COUNT_4 <= (others => '0');
      X16CLK_EN_4  <= '0';
    end if;
  end process;

  process
  begin
    wait until rising_edge(CLK);
    case STATE_4 is
      when IDLE =>
        if STREAM_3_STB = '1'  then
          STREAM_3_ACK <= '1';
          DATA_4 <= STREAM_3;
          STATE_4     <= WAIT_EN;
        end if;
      when WAIT_EN =>
        STREAM_3_ACK <= '0';
        if X16CLK_EN_4 = '1' then
          STATE_4 <= START;
        end if;
      when START =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX0;
        end if;
        TX <= '0'; 
      when TX0 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX1;
        end if;
        TX <= DATA_4(0);
      when TX1 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX2;
        end if;
        TX <= DATA_4(1);
      when TX2 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX3;
        end if;
        TX <= DATA_4(2);
      when TX3 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX4;
        end if;
        TX <= DATA_4(3);
      when TX4 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX5;
        end if;
        TX <= DATA_4(4);
      when TX5 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX6;
        end if;
        TX <= DATA_4(5);
      when TX6 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= TX7;
        end if;
        TX <= DATA_4(6);
      when TX7 =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= STOP;
        end if;
        TX <= DATA_4(7);
      when STOP =>
        if X16CLK_EN_4 = '1' then
          STATE_4 <= IDLE;
        end if;
        TX <= '1';
      when others =>
        STATE_4 <= IDLE;
      end case;
    if RST = '1' then
      STREAM_3_ACK <= '0';
      STATE_4 <= IDLE;
    end if; 
  end process;
  --file: ./size_test.py, line: 53
  --stream 3 Resizer(1, 8)
  STREAM_1_ACK <= STREAM_3_ACK;
  STREAM_3_STB <= STREAM_1_STB;
  STREAM_3 <= STREAM_1(7 downto 0);

  --file: ./size_test.py, line: 24
  --serial input port baud rate generator
  process
  begin
    wait until rising_edge(CLK);
    if BAUD_COUNT_0 = CLOCK_DIVIDER_0 then
      BAUD_COUNT_0 <= (others => '0');
      X16CLK_EN_0  <= '1';
    else
      BAUD_COUNT_0 <= BAUD_COUNT_0 + 1;
      X16CLK_EN_0  <= '0';
    end if;
    if RST = '1' then
      BAUD_COUNT_0 <= (others => '0');
      X16CLK_EN_0  <= '0';
    end if;
  end process;

  --synchronise and filter
  process
  begin
    wait until rising_edge(CLK);
    SERIAL_DEGLITCH_0 <= SERIAL_DEGLITCH_0(0) & RX;
    if X16CLK_EN_0 = '1' then
      if SERIAL_DEGLITCH_0(1) = '1' then
        if COUNT_0 = 3 then
          INT_SERIAL_0 <= '1';
        else 
          COUNT_0 <= COUNT_0 + 1;
        end if;
      else
        if COUNT_0 = 0 then
          INT_SERIAL_0 <= '0';
        else
          COUNT_0 <= COUNT_0 - 1;
        end if;
      end if;
    end if;
  end process;

  process
  begin
    wait until rising_edge(CLK);
	 if X16CLK_EN_0 = '1' then 
      if BIT_SPACING_0 = 15 then
        BIT_SPACING_0 <= 0;
      else
        BIT_SPACING_0 <= BIT_SPACING_0 + 1;
      end if;
    end if;
    case STATE_0 is
      when IDLE =>
        BIT_SPACING_0 <= 0;
        if X16CLK_EN_0 = '1' and INT_SERIAL_0 = '0' then
          STATE_0 <= START;
        end if;
      when START =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 7 then
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX0;
        end if; 
      when RX0 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(0) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX1;
        end if;
      when RX1 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(1) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX2;
        end if;
      when RX2 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(2) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX3;
        end if;
      when RX3 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(3) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX4;
        end if;
      when RX4 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(4) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX5;
        end if;
      when RX5 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(5) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX6;
        end if;
      when RX6 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(6) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= RX7;
        end if;
      when RX7 =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
          STREAM_0(7) <= INT_SERIAL_0;
          BIT_SPACING_0 <= 0;
          STATE_0 <= STOP;
        end if;
      when STOP =>
        if X16CLK_EN_0 = '1' and BIT_SPACING_0 = 15 then
            BIT_SPACING_0 <= 0;
            STATE_0 <= OUTPUT_DATA;
        end if;
      when OUTPUT_DATA =>
          STREAM_0_STB <= '1';
          if STREAM_0_ACK = '1' then
            STREAM_0_STB <= '0';
            STATE_0 <= IDLE;
          end if;
      when others =>
        STATE_0 <= IDLE;
    end case;
    if RST = '1' then
      STATE_0 <= IDLE;
      STREAM_0_STB <= '0';
    end if; 
  end process;

  -- process
  process
    variable INSTRUCTION : std_logic_vector(40 downto 0);
  begin
    wait until rising_edge(CLK);
    INSTRUCTION := INSTRUCTIONS_2(to_integer(PC_2));
    OPERATION_2 <= INSTRUCTION(40 downto 36);
    SRCA_2      <= INSTRUCTION(35 downto 32);
    SRCB_2      <= INSTRUCTION(3 downto 0);
    IMMEDIATE_2 <= INSTRUCTION(31 downto 0);
  end process;

  process
    variable REGA         : std_logic_vector(31 downto 0);
    variable REGB         : std_logic_vector(31 downto 0);
    variable DEST         : std_logic_vector(3 downto 0);
    variable RESULT       : std_logic_vector(31 downto 0);
    variable RESULT_DEL   : std_logic_vector(31 downto 0);
    variable REGISTERS_EN : std_logic;
    variable MODULO       : unsigned(31 downto 0);
    variable FLAG_EQ      : std_logic;
    variable FLAG_NE      : std_logic;
    variable FLAG_GT      : std_logic;
    variable FLAG_GE      : std_logic;
  begin
    wait until rising_edge(CLK);
    REGISTERS_EN := '0';
    case STATE_2 is
      when STALL =>
        PC_2 <= PC_2 + 1;
        STATE_2 <= EXECUTE;
      when EXECUTE =>
        REGA := REGISTERS_2(to_integer(unsigned(SRCA_2)));
        REGB := REGISTERS_2(to_integer(unsigned(SRCB_2)));
        DEST := SRCA_2;
        RESULT := REGA;
        PC_2 <= PC_2 + 1;

        --share comparator logic
        if REGA = REGB then
          FLAG_EQ := '1';
        else
          FLAG_EQ := '0';
        end if;

        if signed(REGA) > signed(REGB) then
          FLAG_GT := '1';
        else
          FLAG_GT := '0';
        end if;

        FLAG_NE := not FLAG_EQ;
        FLAG_GE := FLAG_GT or FLAG_EQ;

        --execute instructions
        case OPERATION_2 is
          when OP_MOVE_2 => 
            RESULT := REGB;
            REGISTERS_EN := '1';
          when OP_MUL_2  => 
            RESULT := STD_RESIZE( MUL(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_ADD_2  => 
            RESULT := STD_RESIZE( ADD(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_SUB_2  => 
            RESULT := STD_RESIZE( SUB(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_BAND_2 => 
            RESULT := STD_RESIZE(BAND(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_BOR_2  => 
            RESULT := STD_RESIZE( BOR(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_BXOR_2 => 
            RESULT := STD_RESIZE(BXOR(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_SL_2   => 
            RESULT := STD_RESIZE(  SL(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_SR_2   => 
            RESULT := STD_RESIZE(  SR(REGA, REGB), 32);
            REGISTERS_EN := '1';
          when OP_EQ_2   => 
            RESULT := (others => FLAG_EQ);
            REGISTERS_EN := '1';
          when OP_NE_2   => 
            RESULT := (others => FLAG_NE);
            REGISTERS_EN := '1';
          when OP_GT_2   => 
            RESULT := (others => FLAG_GT);
            REGISTERS_EN := '1';
          when OP_GE_2   => 
            RESULT := (others => FLAG_GE);
            REGISTERS_EN := '1';
          when OP_IMM_2  => 
            RESULT := IMMEDIATE_2;
            REGISTERS_EN := '1';
          when OP_JMP_2 =>
            STATE_2 <= STALL;
            PC_2 <= resize(unsigned(IMMEDIATE_2), 6);
          when OP_JMPF_2 =>
            if RESULT_DEL = "00000000000000000000000000000000" then
              STATE_2 <= STALL;
              PC_2 <= resize(unsigned(IMMEDIATE_2), 6);
            end if;
          when OP_WAIT_US_2 =>
            STATE_2 <= WAIT_US;
            PC_2 <= PC_2;

          when OP_WRITE_1_2 =>
            STATE_2 <= WRITE_STREAM_1;
            DEST := SRCA_2;
            PC_2 <= PC_2;
          when OP_READ_0_2 =>
            STATE_2 <= READ_STREAM_0;
            PC_2 <= PC_2;
          when others => null;
        end case;

        --write back results
        RESULT_DEL := RESULT;

      when READ_STREAM_0 =>
        if STREAM_0_STB = '1' then
          STREAM_0_ACK <= '1';
          REGISTERS_EN := '1';
          RESULT := STD_RESIZE(STREAM_0, 32);
          STATE_2 <= ACK_STREAM_0;
        end if;
      when ACK_STREAM_0 =>
        STREAM_0_ACK <= '0';
        STATE_2 <= EXECUTE;
        PC_2 <= PC_2 + 1;
      when WRITE_STREAM_1 =>
        STREAM_1_STB <= '1';
        STREAM_1 <= STD_RESIZE(REGA, 32);
        if STREAM_1_ACK = '1' then
          STREAM_1_STB <= '0';
          STATE_2 <= EXECUTE;
          PC_2 <= PC_2 + 1;
        end if;
      when WAIT_US =>
        if TIMER_1uS = '1'then
          PC_2 <= PC_2 + 1;
          STATE_2 <= EXECUTE;
        end if;
    end case;

    if RST = '1' then
      STATE_2 <= STALL;
      PC_2 <= "000000";
      STREAM_0_ACK <= '0';
      STREAM_1_STB <= '0';
    end if;
    if REGISTERS_EN = '1' then
      REGISTERS_2(to_integer(unsigned(DEST))) <= RESULT;
    end if;
  end process;



end architecture RTL;