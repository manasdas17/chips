--+============================================================================+
--|                                                                            |
--|                     This file was generated by Chips                       |
--|                                                                            |
--|                                  Chips                                     |
--|                                                                            |
--|                      http://github.com/dawsonjon/chips                     |
--|                                                                            |
--|                                                             Python powered |
--+============================================================================+

-- generated by python streams library
-- date generated  : UTC 2011-05-27 15:31:25
-- platform        : linux2
-- python version  : 2.7.1+ (r271:86832, Apr 11 2011, 18:13:53) [GCC 4.5.2]
-- streams version : 0.1.1

--+============================================================================+
--|                             **END OF HEADER**                              |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                    **START OF EXTERNAL DEPENDENCIES**                      |
--+============================================================================+



--+============================================================================+
--|                     **END OF EXTERNAL DEPENDENCIES**                       |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                     **START OF AUTO GENERATED CODE**                       |
--+============================================================================+

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is

end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ABSOLUTE(
    A : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(abs(signed(A)));
  end ABSOLUTE;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --logical negation
  function LNOT(
    A : std_logic_vector) return std_logic_vector is
  begin
    if 
      A = std_logic_vector(to_signed(0, A'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LNOT;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;
  constant TIMER_10us_MAX : integer := 49;
  signal TIMER_10us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_10us : std_logic;
  constant TIMER_100us_MAX : integer := 49;
  signal TIMER_100us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_100us : std_logic;
  constant TIMER_1ms_MAX : integer := 49;
  signal TIMER_1ms_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1ms : std_logic;

  signal CLK : std_logic;
  signal RST : std_logic;
  signal STREAM_1     : std_logic_vector(8 downto 0);
  signal STREAM_1_STB : std_logic;
  signal STREAM_1_ACK : std_logic;
  signal STATE_1 : UNARY_STATE_TYPE;
  type LOOKUP_1_TYPE is array (0 to 99) of std_logic_vector(8 downto 0);
  signal LOOKUP_1 : LOOKUP_1_TYPE := (
0 => "000000000",
1 => "000000010",
2 => "000000100",
3 => "000000110",
4 => "000001000",
5 => "000001010",
6 => "000001100",
7 => "000001110",
8 => "000010000",
9 => "000010010",
10 => "000010100",
11 => "000010110",
12 => "000011000",
13 => "000011010",
14 => "000011100",
15 => "000011110",
16 => "000100000",
17 => "000100010",
18 => "000100100",
19 => "000100110",
20 => "000101000",
21 => "000101010",
22 => "000101100",
23 => "000101110",
24 => "000110000",
25 => "000110010",
26 => "000110100",
27 => "000110110",
28 => "000111000",
29 => "000111010",
30 => "000111100",
31 => "000111110",
32 => "001000000",
33 => "001000011",
34 => "001000101",
35 => "001000111",
36 => "001001001",
37 => "001001011",
38 => "001001101",
39 => "001001111",
40 => "001010001",
41 => "001010011",
42 => "001010101",
43 => "001010111",
44 => "001011001",
45 => "001011011",
46 => "001011101",
47 => "001011111",
48 => "001100001",
49 => "001100011",
50 => "001100101",
51 => "001100111",
52 => "001101001",
53 => "001101011",
54 => "001101101",
55 => "001101111",
56 => "001110001",
57 => "001110011",
58 => "001110101",
59 => "001110111",
60 => "001111001",
61 => "001111011",
62 => "001111101",
63 => "001111111",
64 => "010000001",
65 => "010000011",
66 => "010000110",
67 => "010001000",
68 => "010001010",
69 => "010001100",
70 => "010001110",
71 => "010010000",
72 => "010010010",
73 => "010010100",
74 => "010010110",
75 => "010011000",
76 => "010011010",
77 => "010011100",
78 => "010011110",
79 => "010100000",
80 => "010100010",
81 => "010100100",
82 => "010100110",
83 => "010101000",
84 => "010101010",
85 => "010101100",
86 => "010101110",
87 => "010110000",
88 => "010110010",
89 => "010110100",
90 => "010110110",
91 => "010111000",
92 => "010111010",
93 => "010111100",
94 => "010111110",
95 => "011000000",
96 => "011000010",
97 => "011000100",
98 => "011000110",
99 => "011001001"
  );

  signal STREAM_0     : std_logic_vector(7 downto 0);
  signal STREAM_0_STB : std_logic;
  signal STREAM_0_ACK : std_logic;

  signal STREAM_2       : std_logic_vector(25 downto 0);
  signal STREAM_2_STB   : std_logic;
  signal STREAM_2_ACK   : std_logic;
  constant OP_IMM_3 : std_logic_vector(3 downto 0) := "0000";
  constant OP_MOVE_3 : std_logic_vector(3 downto 0) := "0001";
  constant OP_GE_3 : std_logic_vector(3 downto 0) := "0010";
  constant OP_LNOT_3 : std_logic_vector(3 downto 0) := "0011";
  constant OP_JMPF_3 : std_logic_vector(3 downto 0) := "0100";
  constant OP_JMP_3 : std_logic_vector(3 downto 0) := "0101";
  constant OP_GT_3 : std_logic_vector(3 downto 0) := "0110";
  constant OP_MUL_3 : std_logic_vector(3 downto 0) := "0111";
  constant OP_SR_3 : std_logic_vector(3 downto 0) := "1000";
  constant OP_ADD_3 : std_logic_vector(3 downto 0) := "1001";
  constant OP_DIV_3 : std_logic_vector(3 downto 0) := "1010";
  constant OP_SUB_3 : std_logic_vector(3 downto 0) := "1011";
  constant OP_NOOP_3 : std_logic_vector(3 downto 0) := "1100";
  constant OP_READ_1_3 : std_logic_vector(3 downto 0) := "1101";
  constant OP_WRITE_2_3 : std_logic_vector(3 downto 0) := "1110";
  type PROCESS_3_STATE_TYPE is (STALL, EXECUTE, DIVIDE_0, DIVIDE_1, DIVIDE_2, READ_STREAM_1, ACK_STREAM_1, WRITE_STREAM_2);
  type INSTRUCTIONS_TYPE_3  is array (0 to 156) of std_logic_vector(33 downto 0);
  type REGISTERS_TYPE_3     is array (0 to 15) of std_logic_vector(25 downto 0);

  --Pipeline stage 0 outputs
  signal OPERATION_0_3  : std_logic_vector(3 downto 0);
  signal SRCA_0_3       : std_logic_vector(3 downto 0);
  signal SRCB_0_3       : std_logic_vector(3 downto 0);
  signal IMMEDIATE_0_3  : std_logic_vector(25 downto 0);
  --Pipeline stage 1 outputs
  signal OPERATION_1_3    : std_logic_vector(3 downto 0);
  signal IMMEDIATE_1_3    : std_logic_vector(25 downto 0);
  signal REGA_1_3         : std_logic_vector(25 downto 0);
  signal REGB_1_3         : std_logic_vector(25 downto 0);
  signal DEST_1_3         : std_logic_vector(3 downto 0);
  --Pipeline stage 2 outputs
  signal OPERATION_2_3    : std_logic_vector(3 downto 0);
  signal IMMEDIATE_2_3    : std_logic_vector(25 downto 0);
  signal REGA_2_3         : std_logic_vector(25 downto 0);
  signal REGB_2_3         : std_logic_vector(25 downto 0);
  signal DEST_2_3         : std_logic_vector(3 downto 0);
  signal PRODUCT_A_2_3    : signed(35 downto 0);
  signal PRODUCT_B_2_3    : signed(35 downto 0);
  signal PRODUCT_C_2_3    : signed(35 downto 0);
  signal PRODUCT_D_2_3    : signed(35 downto 0);
  --Pipeline stage 3 outputs
  signal RESULT_3_3       : std_logic_vector(25 downto 0);
  signal DEST_3_3         : std_logic_vector(3 downto 0);
  signal REGISTER_EN_3_3  : std_logic;
  signal STATE_3          : PROCESS_3_STATE_TYPE;
  signal PC_3             : unsigned(7 downto 0);
  signal ZERO_3           : std_logic;
  signal A_3              : std_logic_vector(25 downto 0);
  signal B_3              : std_logic_vector(25 downto 0);
  signal QUOTIENT_3       : std_logic_vector(25 downto 0);
  signal SHIFTER_3        : std_logic_vector(25 downto 0);
  signal REMAINDER_3      : std_logic_vector(25 downto 0);
  signal COUNT_3          : integer range 0 to 26;
  signal SIGN_3           : std_logic;
  signal INSTRUCTIONS_3   : INSTRUCTIONS_TYPE_3 := (
0 => OP_IMM_3 & "0001" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 40
1 => OP_IMM_3 & "0010" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 35
2 => OP_IMM_3 & "0011" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 36
3 => OP_IMM_3 & "0100" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 41
4 => OP_IMM_3 & "0101" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 39
5 => OP_IMM_3 & "0110" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 37
6 => OP_IMM_3 & "0111" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 38
7 => OP_READ_1_3 & "0001" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/streams.py line: 399
8 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
9 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
10 => OP_MOVE_3 & "1000" & "00000000000000000000000001", -- file: ./example_2_taylor_series.py line: 40
11 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
12 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
13 => OP_MOVE_3 & "0010" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
14 => OP_IMM_3 & "1000" & "00000000000000000000000011", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
15 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
16 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
17 => OP_MOVE_3 & "0011" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
18 => OP_IMM_3 & "1000" & "11111111111111111111111111", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
19 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
20 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
21 => OP_MOVE_3 & "0100" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
22 => OP_IMM_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
23 => OP_MOVE_3 & "1001" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
24 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
25 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
26 => OP_GE_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 216
27 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
28 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
29 => OP_LNOT_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 180
30 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
31 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
32 => OP_JMPF_3 & "1000" & "00000000000000000000100011", -- file: None line: None
33 => OP_JMP_3 & "0000" & "00000000000000000010010100", -- file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py line: 100
34 => OP_JMP_3 & "0000" & "00000000000000000000100011", -- file: None line: None
35 => OP_IMM_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
36 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
37 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
38 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
39 => OP_IMM_3 & "1000" & "00000000000000000001000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
40 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
41 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
42 => OP_MOVE_3 & "0110" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
43 => OP_MOVE_3 & "1000" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
44 => OP_MOVE_3 & "1001" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
45 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
46 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
47 => OP_GT_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 214
48 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
49 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
50 => OP_LNOT_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 180
51 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
52 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
53 => OP_JMPF_3 & "1000" & "00000000000000000000111000", -- file: None line: None
54 => OP_JMP_3 & "0000" & "00000000000000000001001101", -- file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py line: 100
55 => OP_JMP_3 & "0000" & "00000000000000000000111000", -- file: None line: None
56 => OP_MOVE_3 & "1000" & "00000000000000000000000110", -- file: ./example_2_taylor_series.py line: 37
57 => OP_MOVE_3 & "1001" & "00000000000000000000000001", -- file: ./example_2_taylor_series.py line: 40
58 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
59 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
60 => OP_MUL_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 190
61 => OP_IMM_3 & "1001" & "00000000000000000000000110", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
62 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
63 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
64 => OP_SR_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 202
65 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
66 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
67 => OP_MOVE_3 & "0110" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
68 => OP_MOVE_3 & "1000" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
69 => OP_IMM_3 & "1001" & "00000000000000000000000001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
70 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
71 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
72 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 186
73 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
74 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
75 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
76 => OP_JMP_3 & "0000" & "00000000000000000000101011", -- file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py line: 101
77 => OP_IMM_3 & "1000" & "00000000000000000000000001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
78 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
79 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
80 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
81 => OP_IMM_3 & "1000" & "00000000000000000000000001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
82 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
83 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
84 => OP_MOVE_3 & "0111" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
85 => OP_MOVE_3 & "1000" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
86 => OP_MOVE_3 & "1001" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
87 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
88 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
89 => OP_GE_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 216
90 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
91 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
92 => OP_LNOT_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 180
93 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
94 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
95 => OP_JMPF_3 & "1000" & "00000000000000000001100010", -- file: None line: None
96 => OP_JMP_3 & "0000" & "00000000000000000001110011", -- file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py line: 100
97 => OP_JMP_3 & "0000" & "00000000000000000001100010", -- file: None line: None
98 => OP_MOVE_3 & "1000" & "00000000000000000000000111", -- file: ./example_2_taylor_series.py line: 38
99 => OP_MOVE_3 & "1001" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
100 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
101 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
102 => OP_MUL_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 190
103 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
104 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
105 => OP_MOVE_3 & "0111" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
106 => OP_MOVE_3 & "1000" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
107 => OP_IMM_3 & "1001" & "00000000000000000000000001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
108 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
109 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
110 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 186
111 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
112 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
113 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
114 => OP_JMP_3 & "0000" & "00000000000000000001010101", -- file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py line: 101
115 => OP_MOVE_3 & "1000" & "00000000000000000000000010", -- file: ./example_2_taylor_series.py line: 35
116 => OP_MOVE_3 & "1001" & "00000000000000000000000100", -- file: ./example_2_taylor_series.py line: 41
117 => OP_MOVE_3 & "1010" & "00000000000000000000000110", -- file: ./example_2_taylor_series.py line: 37
118 => OP_MOVE_3 & "1011" & "00000000000000000000000111", -- file: ./example_2_taylor_series.py line: 38
119 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
120 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
121 => OP_DIV_3 & "1010" & "00000000000000000000001011", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 194
122 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
123 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
124 => OP_MUL_3 & "1001" & "00000000000000000000001010", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 190
125 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
126 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
127 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 186
128 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
129 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
130 => OP_MOVE_3 & "0010" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
131 => OP_IMM_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
132 => OP_MOVE_3 & "1001" & "00000000000000000000000100", -- file: ./example_2_taylor_series.py line: 41
133 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
134 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
135 => OP_SUB_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 220
136 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
137 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
138 => OP_MOVE_3 & "0100" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
139 => OP_MOVE_3 & "1000" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
140 => OP_IMM_3 & "1001" & "00000000000000000000000010", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 170
141 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
142 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
143 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 186
144 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
145 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
146 => OP_MOVE_3 & "0011" & "00000000000000000000001000", -- file: /usr/local/lib/python2.7/dist-packages/chips/instruction.py line: 449
147 => OP_JMP_3 & "0000" & "00000000000000000000010110", -- file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py line: 101
148 => OP_MOVE_3 & "1000" & "00000000000000000000000010", -- file: ./example_2_taylor_series.py line: 35
149 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
150 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
151 => OP_WRITE_2_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.7/dist-packages/chips/streams.py line: 864
152 => OP_JMP_3 & "0000" & "00000000000000000000000111", -- file: ./example_2_taylor_series.py line: 68
153 => OP_JMP_3 & "0000" & "00000000000000000010011001", -- file: None line: None
154 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
155 => OP_NOOP_3 & "0000" & "00000000000000000000000000", -- file: None line: None
156 => OP_NOOP_3 & "0000" & "00000000000000000000000000"); -- file: None line: None
  signal MOD_DIV_3        : std_logic;

begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    TIMER_10us <= '0';
    TIMER_100us <= '0';
    TIMER_1ms <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
       if TIMER_10us_COUNT = 0 then
         TIMER_10us_COUNT <= TIMER_10us_MAX;
         TIMER_10us <= '1';
         if TIMER_100us_COUNT = 0 then
           TIMER_100us_COUNT <= TIMER_100us_MAX;
           TIMER_100us <= '1';
           if TIMER_1ms_COUNT = 0 then
             TIMER_1ms_COUNT <= TIMER_1ms_MAX;
             TIMER_1ms <= '1';
           else
             TIMER_1ms_COUNT <= TIMER_1ms_COUNT - 1;
           end if;
         else
           TIMER_100us_COUNT <= TIMER_100us_COUNT - 1;
         end if;
       else
         TIMER_10us_COUNT <= TIMER_10us_COUNT - 1;
       end if;
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
       TIMER_10us_COUNT <= TIMER_10us_MAX;
       TIMER_10us <= '0';
       TIMER_100us_COUNT <= TIMER_100us_MAX;
       TIMER_100us <= '0';
       TIMER_1ms_COUNT <= TIMER_1ms_MAX;
       TIMER_1ms <= '0';
    end if;
  end process;

  --internal clock generator
  process
  begin
    while True loop
      CLK <= '0';
      wait for 5 ns;
      CLK <= '1';
      wait for 5 ns;
    end loop;
    wait;
  end process;

  --internal reset generator
  process
  begin
    RST <= '1';
    wait for 20 ns;
    RST <= '0';
    wait;
  end process;

  --file: ./example_2_taylor_series.py, line: 94
  --OutPort(2, 26)
  process
    file OUTFILE : text open write_mode is "resp_2.txt";
    variable OUTLINE : LINE;
    variable VALUE : integer;
  begin
    wait until rising_edge(CLK);
    STREAM_2_ACK <= '0';
    if STREAM_2_STB = '1' then
      STREAM_2_ACK <= '1';
    end if;    if STREAM_2_STB = '1' and STREAM_2_ACK = '1' then
      VALUE := to_integer(signed(STREAM_2));
      write(OUTLINE, VALUE);
      writeline(OUTFILE, OUTLINE);
    end if;  end process;

  --file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py, line: 85
  --STREAM 1 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_1 is
      when UNARY_INPUT =>
        if STREAM_0_STB = '1' then
          STREAM_0_ACK <= '1';
          STREAM_1_STB <= '1';
          STREAM_1 <= LOOKUP_1(to_integer(unsigned(STREAM_0)));
          STATE_1 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_0_ACK <= '0';
        if STREAM_1_ACK = '1' then
           STREAM_1_STB <= '0';
           STATE_1 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_1_STB <= '0';
       STREAM_0_ACK <= '0';
       STATE_1 <= UNARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.7/dist-packages/chips/__init__.py, line: 85
  --STREAM 0 Counter(0, 99, 1, 8)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_0_STB <= '1';
    if STREAM_0_ACK = '1' then
      STREAM_0_STB <= '0';
      STREAM_0 <= STD_RESIZE(ADD(STREAM_0, "00000001"), 8);
      if STREAM_0 = "01100011" then
        STREAM_0 <= "00000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_0_STB <= '0';
      STREAM_0 <= "00000000";
    end if;
  end process;

  -- PIPELINE STAGE 0 - INSTRUCTION FETCH
  process
    variable INSTRUCTION : std_logic_vector(33 downto 0);
  begin
    wait until rising_edge(CLK);
    if STATE_3 = EXECUTE or STATE_3 = STALL then
      INSTRUCTION := INSTRUCTIONS_3(to_integer(PC_3));
      SRCA_0_3      <= INSTRUCTION(29 downto 26);
      SRCB_0_3      <= INSTRUCTION(3 downto 0);
      IMMEDIATE_0_3 <= INSTRUCTION(25 downto 0);
      OPERATION_0_3 <= INSTRUCTION(33 downto 30);
    end if;
  end process;

  -- PIPELINE STAGE 1 - REGISTER FETCH
  process
    variable REGISTERS : REGISTERS_TYPE_3;
  begin
    wait until rising_edge(CLK);
    if REGISTER_EN_3_3 = '1' then
      REGISTERS(to_integer(unsigned(DEST_3_3))) := RESULT_3_3;
    end if;
    if STATE_3 = EXECUTE or STATE_3 = STALL then
      REGA_1_3      <= REGISTERS(to_integer(unsigned(SRCA_0_3)));
      REGB_1_3      <= REGISTERS(to_integer(unsigned(SRCB_0_3)));
      DEST_1_3      <= SRCA_0_3;
      OPERATION_1_3 <= OPERATION_0_3;
      IMMEDIATE_1_3 <= IMMEDIATE_0_3;
    end if;
  end process;

  -- PIPELINE STAGE 2 - PRE_EXECUTE
  process
    variable A_35 : signed(34 downto 0);
    variable B_35 : signed(34 downto 0);
    variable A_LO : signed(17 downto 0);
    variable A_HI : signed(17 downto 0);
    variable B_LO : signed(17 downto 0);
    variable B_HI : signed(17 downto 0);
  begin
    wait until rising_edge(CLK);
    if STATE_3 = EXECUTE or STATE_3 = STALL then
      REGA_2_3      <= REGA_1_3;
      REGB_2_3      <= REGB_1_3;
      DEST_2_3      <= DEST_1_3;
      OPERATION_2_3 <= OPERATION_1_3;
      IMMEDIATE_2_3 <= IMMEDIATE_1_3;
      A_35 := resize(signed(REGA_1_3), 35);
      B_35 := resize(signed(REGB_1_3), 35);
      A_LO := signed('0' & A_35(16 downto 0));
      A_HI := signed(      A_35(34 downto 17));
      B_LO := signed('0' & B_35(16 downto 0));
      B_HI := signed(      B_35(34 downto 17));
      PRODUCT_A_2_3 <= A_LO * B_LO;
      PRODUCT_B_2_3 <= A_HI * B_LO;
      PRODUCT_C_2_3 <= A_LO * B_HI;
      PRODUCT_D_2_3 <= A_HI * B_HI;
    end if;
  end process;

  -- PIPELINE STAGE 3 - EXECUTE
  process
    variable MODULO       : unsigned(25 downto 0);
    variable STALL_COUNT  : integer range 0 to 2;
    variable FLAG_EQ : std_logic;
    variable FLAG_GT : std_logic;
    variable FLAG_GE : std_logic;
    variable SUM : std_logic_vector(69 downto 0);
  begin
    wait until rising_edge(CLK);
    REGISTER_EN_3_3 <= '0';
    case STATE_3 is
      when STALL =>
        PC_3 <= PC_3 + 1;
        if STALL_COUNT = 0 then
          STATE_3 <= EXECUTE;
        else
          STALL_COUNT := STALL_COUNT - 1;
        end if;
      when EXECUTE =>
        DEST_3_3 <= DEST_2_3;
        RESULT_3_3 <= REGA_2_3;
        PC_3 <= PC_3 + 1;

        --share comparator logic
        if REGA_2_3 = REGB_2_3 then
          FLAG_EQ := '1';
        else
          FLAG_EQ := '0';
        end if;

        if signed(REGA_2_3) > signed(REGB_2_3) then
          FLAG_GT := '1';
        else
          FLAG_GT := '0';
        end if;

        FLAG_GE := FLAG_GT or FLAG_EQ;

        --execute instructions
        case OPERATION_2_3 is
          when OP_MOVE_3 => 
            RESULT_3_3 <= REGB_2_3;
            REGISTER_EN_3_3 <= '1';
          when OP_NOOP_3 => 
            REGISTER_EN_3_3 <= '0';
            RESULT_3_3 <= RESULT_3_3;
          when OP_MUL_3  => 
            SUM := std_logic_vector(
              resize(PRODUCT_A_2_3, 70) +
              resize(shift_left(PRODUCT_B_2_3, 17), 70) +
              resize(shift_left(PRODUCT_C_2_3, 17), 70) +
              resize(shift_left(PRODUCT_D_2_3, 34), 70)
            );
            RESULT_3_3 <= STD_RESIZE(SUM, 26);
            REGISTER_EN_3_3 <= '1';
          when OP_ADD_3  => 
            RESULT_3_3 <= STD_RESIZE( ADD(REGA_2_3, REGB_2_3), 26);
            REGISTER_EN_3_3 <= '1';
          when OP_SUB_3  => 
            RESULT_3_3 <= STD_RESIZE( SUB(REGA_2_3, REGB_2_3), 26);
            REGISTER_EN_3_3 <= '1';
          when OP_SR_3   => 
            RESULT_3_3 <= STD_RESIZE(  SR(REGA_2_3, REGB_2_3), 26);
            REGISTER_EN_3_3 <= '1';
          when OP_GT_3   => 
            RESULT_3_3 <= (others => FLAG_GT);
            REGISTER_EN_3_3 <= '1';
          when OP_GE_3   => 
            RESULT_3_3 <= (others => FLAG_GE);
            REGISTER_EN_3_3 <= '1';
          when OP_IMM_3  => 
            RESULT_3_3 <= IMMEDIATE_2_3;
            REGISTER_EN_3_3 <= '1';
          when OP_LNOT_3  => 
            RESULT_3_3 <= STD_RESIZE( LNOT(REGA_2_3), 26);
            REGISTER_EN_3_3 <= '1';
          when OP_JMP_3 =>
            STATE_3 <= STALL;
            STALL_COUNT := 2;
            PC_3 <= resize(unsigned(IMMEDIATE_2_3), 8);
          when OP_JMPF_3 =>
            if RESULT_3_3 = "00000000000000000000000000" then
              STATE_3 <= STALL;
              STALL_COUNT := 2;
              PC_3 <= resize(unsigned(IMMEDIATE_2_3), 8);
            end if;
          when OP_DIV_3 =>
            MOD_DIV_3 <= '1';
            A_3 <= std_logic_vector(abs(signed(REGA_2_3)));
            B_3 <= std_logic_vector(abs(signed(REGB_2_3)));
            SIGN_3 <= REGA_2_3(25) xor REGB_2_3(25);
            STATE_3 <= DIVIDE_0;
            PC_3 <= PC_3;
          when OP_WRITE_2_3 =>
            STATE_3 <= WRITE_STREAM_2;
            STREAM_2 <= STD_RESIZE(REGA_2_3, 26);
            STREAM_2_STB <= '0';
            PC_3 <= PC_3;
          when OP_READ_1_3 =>
            STATE_3 <= READ_STREAM_1;
            PC_3 <= PC_3;
          when others => null;
        end case;

      when DIVIDE_0 =>
        QUOTIENT_3 <= (others => '0');
        SHIFTER_3 <= (others => '0');
        SHIFTER_3(0) <= A_3(25);
        A_3 <= A_3(24 downto 0) & '0';
        COUNT_3 <= 25;
        STATE_3 <= DIVIDE_1;
      when DIVIDE_1 => --subtract
       --if SHIFTER - B is positive or zero
       if REMAINDER_3(25) = '0' then
         SHIFTER_3(25 downto 1) <= REMAINDER_3(24 downto 0);
       else
         SHIFTER_3(25 downto 1) <= SHIFTER_3(24 downto 0);
       end if;
       SHIFTER_3(0) <= A_3(25);
       A_3 <= A_3(24 downto 0) & '0';
       QUOTIENT_3 <= QUOTIENT_3(24 downto 0) & not(REMAINDER_3(25));
       if COUNT_3 = 0 then
         STATE_3 <= DIVIDE_2;
       else
         COUNT_3 <= COUNT_3 - 1;
       end if;
      when DIVIDE_2 =>
       REGISTER_EN_3_3 <= '1';
       if MOD_DIV_3 = '1' then --if division
         if SIGN_3 = '1' then --if negative
           RESULT_3_3 <= std_logic_vector(-signed(QUOTIENT_3));
         else
           RESULT_3_3 <= QUOTIENT_3;
         end if;
       else
         MODULO := unsigned(SHIFTER_3)/2;
         if SIGN_3 = '1' then --if negative
           RESULT_3_3 <= std_logic_vector(0-MODULO);
         else
           RESULT_3_3 <= std_logic_vector(  MODULO);
         end if;
       end if;
       STATE_3 <= EXECUTE;
       PC_3 <= PC_3 + 1;
      when READ_STREAM_1 =>
        if STREAM_1_STB = '1' then
          STREAM_1_ACK <= '1';
          REGISTER_EN_3_3 <= '1';
          RESULT_3_3 <= STD_RESIZE(STREAM_1, 26);
          STATE_3 <= ACK_STREAM_1;
        end if;
      when ACK_STREAM_1 =>
        STREAM_1_ACK <= '0';
        STATE_3 <= EXECUTE;
        PC_3 <= PC_3 + 1;
      when WRITE_STREAM_2 =>
        STREAM_2_STB <= '1';
        if STREAM_2_ACK = '1' then
          STREAM_2_STB <= '0';
          STATE_3 <= EXECUTE;
          PC_3 <= PC_3 + 1;
        end if;
    end case;

    if RST = '1' then
      STATE_3 <= STALL;
      STALL_COUNT := 2;
      PC_3 <= "00000000";
      STREAM_1_ACK <= '0';
      STREAM_2_STB <= '0';
    end if;
  end process;


  --subtractor
  REMAINDER_3 <= std_logic_vector(unsigned(SHIFTER_3) - resize(unsigned(B_3), 26));

end architecture RTL;

--+============================================================================+
--|                       **END OF AUTO GENERATED CODE**                       |
--+============================================================================+