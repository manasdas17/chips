--+============================================================================+
--|   **THIS FILE WAS AUTOMATICALLY GENERATED BY THE PYTHON STREAMS LIBRARY**  |
--+ ============================================================================+
--|                    _       ________________                                |
--|                   (_)---->/                /     _                         |
--|                    _     / PYTHON STREAMS /---->(_)                        |
--|                   (_)-->/________________/                                 |
--|                                                                            |
--+============================================================================+

-- generated by python streams library
-- date generated  : UTC 2011-02-19 19:57:42
-- platform        : linux2
-- python version  : 2.6.6 (r266:84292, Sep 15 2010, 16:22:56) 
--                   [GCC 4.4.5]
-- streams version : 0.1

--+============================================================================+
--|                             **END OF HEADER**                              |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                    **START OF EXTERNAL DEPENDENCIES**                      |
--+============================================================================+



--+============================================================================+
--|                     **END OF EXTERNAL DEPENDENCIES**                       |
--+============================================================================+

--                                   ***                                       

--+============================================================================+
--|                     **START OF AUTO GENERATED CODE**                       |
--+============================================================================+

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity STREAMS_VHDL_MODEL is

end entity STREAMS_VHDL_MODEL;

architecture RTL of STREAMS_VHDL_MODEL is


  --returns the greater of the two parameters
  function MAX(
    A : integer;
    B : integer) return integer is
  begin
    if A > B then
      return A;
    else
      return B;
    end if;
  end MAX;

  --returns a std_logic_vector sum of the two parameters
  function ADD(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) + 
      resize(signed(B), MAX(A'length, B'length) + 1));
    end ADD;

  --returns a std_logic_vector product of the two parameters
  function MUL(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      signed(A) *
      signed(B));
    end MUL;

  --returns a std_logic_vector difference of the two parameters
  function SUB(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'length, B'length) + 1) - 
      resize(signed(B), MAX(A'length, B'length) + 1));
  end SUB;

  --returns A shifted right (arithmetic) by A
  function SR(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_right(signed(A), to_integer(signed(B))));
  end SR;

  --returns A shifted left by B
  function SL(
    A  : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(shift_left(signed(A), to_integer(signed(B))));
  end SL;

  --returns bitwise and of A and B
  --(A and B are resized to the length of the larger first)
  function BAND(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) and
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BAND;

  --returns bitwise or of A and B
  --(A and B are resized to the length of the larger first)
  function BOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) or
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BOR;

  --returns bitwise xor of A and B
  --(A and B are resized to the length of the larger first)
  function BXOR(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) xor
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)));
  end BXOR;

  --equality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function EQ(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) =
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end EQ;

  --inequality comparison of A and B
  --(A and B are resized to the length of the larger first)
  function NE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
    resize(signed(A), MAX(A'LENGTH, B'LENGTH)) /=
    resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end NE;

  --greater than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GT;

  --greater than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function GE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) >=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end GE;

  --less than comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LT(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LT;

  --less than or equal comparison of A and B
  --(A and B are resized to the length of the larger first)
  function LE(
    A : std_logic_vector; 
    B : std_logic_vector) return std_logic_vector is
  begin
    if 
      resize(signed(A), MAX(A'LENGTH, B'LENGTH)) <=
      resize(signed(B), MAX(A'LENGTH, B'LENGTH)) then
      return "1";
    else
      return "0";
    end if;
  end LE;

  --resize A to B bits
  function STD_RESIZE(
    A : std_logic_vector; 
    B : integer) return std_logic_vector is
  begin
    return std_logic_vector(
      resize(signed(A), B));
  end STD_RESIZE;

  type BINARY_STATE_TYPE is (BINARY_INPUT, BINARY_OUTPUT);
  type UNARY_STATE_TYPE is (UNARY_INPUT, UNARY_OUTPUT);
  type TEE_STATE_TYPE is (TEE_INPUT_A, TEE_WAIT_YZ, TEE_WAIT_Y, TEE_WAIT_Z);
  type DIVIDER_STATE_TYPE is (READ_A_B, DIVIDE_1, DIVIDE_2, WRITE_Z);
  type SERIAL_IN_STATE_TYPE is (IDLE, START, RX0, RX1, RX2, RX3, RX4, RX5, RX6, RX7, STOP, OUTPUT_DATA);
  type SERIAL_OUT_STATE_TYPE is (IDLE, START, WAIT_EN, TX0, TX1, TX2, TX3, TX4, TX5, TX6, TX7, STOP);
  type PRINTER_STATE_TYPE is (INPUT_A, SHIFT, OUTPUT_SIGN, OUTPUT_Z, OUTPUT_NL);
  type HEX_PRINTER_STATE_TYPE is (INPUT_A, OUTPUT_SIGN, OUTPUT_DIGITS);

  constant TIMER_1us_MAX : integer := 49;
  signal TIMER_1us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1us : std_logic;
  constant TIMER_10us_MAX : integer := 49;
  signal TIMER_10us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_10us : std_logic;
  constant TIMER_100us_MAX : integer := 49;
  signal TIMER_100us_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_100us : std_logic;
  constant TIMER_1ms_MAX : integer := 49;
  signal TIMER_1ms_COUNT : integer range 0 to TIMER_1us_MAX;
  signal TIMER_1ms : std_logic;

  signal CLK : std_logic;
  signal RST : std_logic;
  signal STREAM_1     : std_logic_vector(8 downto 0);
  signal STREAM_1_STB : std_logic;
  signal STREAM_1_ACK : std_logic;
  signal STATE_1 : UNARY_STATE_TYPE;
  type LOOKUP_1_TYPE is array (0 to 99) of std_logic_vector(8 downto 0);
  signal LOOKUP_1 : LOOKUP_1_TYPE := (
0 => "000000000",
1 => "000000010",
2 => "000000100",
3 => "000000110",
4 => "000001000",
5 => "000001010",
6 => "000001100",
7 => "000001110",
8 => "000010000",
9 => "000010010",
10 => "000010100",
11 => "000010110",
12 => "000011000",
13 => "000011010",
14 => "000011100",
15 => "000011110",
16 => "000100000",
17 => "000100010",
18 => "000100100",
19 => "000100110",
20 => "000101000",
21 => "000101010",
22 => "000101100",
23 => "000101110",
24 => "000110000",
25 => "000110010",
26 => "000110100",
27 => "000110110",
28 => "000111000",
29 => "000111010",
30 => "000111100",
31 => "000111110",
32 => "001000000",
33 => "001000011",
34 => "001000101",
35 => "001000111",
36 => "001001001",
37 => "001001011",
38 => "001001101",
39 => "001001111",
40 => "001010001",
41 => "001010011",
42 => "001010101",
43 => "001010111",
44 => "001011001",
45 => "001011011",
46 => "001011101",
47 => "001011111",
48 => "001100001",
49 => "001100011",
50 => "001100101",
51 => "001100111",
52 => "001101001",
53 => "001101011",
54 => "001101101",
55 => "001101111",
56 => "001110001",
57 => "001110011",
58 => "001110101",
59 => "001110111",
60 => "001111001",
61 => "001111011",
62 => "001111101",
63 => "001111111",
64 => "010000001",
65 => "010000011",
66 => "010000110",
67 => "010001000",
68 => "010001010",
69 => "010001100",
70 => "010001110",
71 => "010010000",
72 => "010010010",
73 => "010010100",
74 => "010010110",
75 => "010011000",
76 => "010011010",
77 => "010011100",
78 => "010011110",
79 => "010100000",
80 => "010100010",
81 => "010100100",
82 => "010100110",
83 => "010101000",
84 => "010101010",
85 => "010101100",
86 => "010101110",
87 => "010110000",
88 => "010110010",
89 => "010110100",
90 => "010110110",
91 => "010111000",
92 => "010111010",
93 => "010111100",
94 => "010111110",
95 => "011000000",
96 => "011000010",
97 => "011000100",
98 => "011000110",
99 => "011001001"
  );

  signal STREAM_0     : std_logic_vector(7 downto 0);
  signal STREAM_0_STB : std_logic;
  signal STREAM_0_ACK : std_logic;

  signal STREAM_2       : std_logic_vector(25 downto 0);
  signal STREAM_2_STB   : std_logic;
  signal STREAM_2_ACK   : std_logic;
  constant OP_IMM_3 : std_logic_vector(3 downto 0) := "0000";
  constant OP_MOVE_3 : std_logic_vector(3 downto 0) := "0001";
  constant OP_GE_3 : std_logic_vector(3 downto 0) := "0010";
  constant OP_EQ_3 : std_logic_vector(3 downto 0) := "0011";
  constant OP_JMPF_3 : std_logic_vector(3 downto 0) := "0100";
  constant OP_JMP_3 : std_logic_vector(3 downto 0) := "0101";
  constant OP_GT_3 : std_logic_vector(3 downto 0) := "0110";
  constant OP_MUL_3 : std_logic_vector(3 downto 0) := "0111";
  constant OP_SR_3 : std_logic_vector(3 downto 0) := "1000";
  constant OP_ADD_3 : std_logic_vector(3 downto 0) := "1001";
  constant OP_DIV_3 : std_logic_vector(3 downto 0) := "1010";
  constant OP_SUB_3 : std_logic_vector(3 downto 0) := "1011";
  constant OP_READ_1_3 : std_logic_vector(3 downto 0) := "1100";
  constant OP_WRITE_2_3 : std_logic_vector(3 downto 0) := "1101";
  type PROCESS_3_STATE_TYPE is (STALL, EXECUTE, DIVIDE_0, DIVIDE_1, DIVIDE_2, READ_STREAM_1, ACK_STREAM_1, WRITE_STREAM_2);
  type INSTRUCTIONS_TYPE_3  is array (0 to 87) of std_logic_vector(33 downto 0);
  type REGISTERS_TYPE_3     is array (0 to 15) of std_logic_vector(25 downto 0);
  signal STATE_3        : PROCESS_3_STATE_TYPE;
  signal REGISTERS_3    : REGISTERS_TYPE_3;
  signal PC_3           : unsigned(6 downto 0);
  signal OPERATION_3    : std_logic_vector(3 downto 0);
  signal SRCA_3         : std_logic_vector(3 downto 0);
  signal SRCB_3         : std_logic_vector(3 downto 0);
  signal IMMEDIATE_3    : std_logic_vector(25 downto 0);
  signal ZERO_3         : std_logic;
  signal A_3            : std_logic_vector(25 downto 0);
  signal B_3            : std_logic_vector(25 downto 0);
  signal QUOTIENT_3     : std_logic_vector(25 downto 0);
  signal SHIFTER_3      : std_logic_vector(25 downto 0);
  signal REMAINDER_3    : std_logic_vector(25 downto 0);
  signal COUNT_3        : integer range 0 to 26;
  signal SIGN_3         : std_logic;
  signal INSTRUCTIONS_3 : INSTRUCTIONS_TYPE_3 := (
0 => OP_IMM_3 & "0001" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 40
1 => OP_IMM_3 & "0010" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 35
2 => OP_IMM_3 & "0011" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 36
3 => OP_IMM_3 & "0100" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 41
4 => OP_IMM_3 & "0101" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 39
5 => OP_IMM_3 & "0110" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 37
6 => OP_IMM_3 & "0111" & "00000000000000000000000000", -- file: ./example_2_taylor_series.py line: 38
7 => OP_READ_1_3 & "0001" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/streams.py line: 148
8 => OP_MOVE_3 & "1000" & "00000000000000000000000001", -- file: ./example_2_taylor_series.py line: 40
9 => OP_MOVE_3 & "0010" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
10 => OP_IMM_3 & "1000" & "00000000000000000000000011", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
11 => OP_MOVE_3 & "0011" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
12 => OP_IMM_3 & "1000" & "11111111111111111111111111", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
13 => OP_MOVE_3 & "0100" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
14 => OP_IMM_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
15 => OP_MOVE_3 & "1001" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
16 => OP_GE_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 139
17 => OP_IMM_3 & "1001" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
18 => OP_EQ_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 134
19 => OP_JMPF_3 & "1000" & "00000000000000000000010110", -- file: None line: None
20 => OP_JMP_3 & "0000" & "00000000000000000001010011", -- file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py line: 62
21 => OP_JMP_3 & "0000" & "00000000000000000000010110", -- file: None line: None
22 => OP_IMM_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
23 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
24 => OP_IMM_3 & "1000" & "00000000000000000001000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
25 => OP_MOVE_3 & "0110" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
26 => OP_MOVE_3 & "1000" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
27 => OP_MOVE_3 & "1001" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
28 => OP_GT_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 138
29 => OP_IMM_3 & "1001" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
30 => OP_EQ_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 134
31 => OP_JMPF_3 & "1000" & "00000000000000000000100010", -- file: None line: None
32 => OP_JMP_3 & "0000" & "00000000000000000000101101", -- file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py line: 62
33 => OP_JMP_3 & "0000" & "00000000000000000000100010", -- file: None line: None
34 => OP_MOVE_3 & "1000" & "00000000000000000000000110", -- file: ./example_2_taylor_series.py line: 37
35 => OP_MOVE_3 & "1001" & "00000000000000000000000001", -- file: ./example_2_taylor_series.py line: 40
36 => OP_MUL_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 126
37 => OP_IMM_3 & "1001" & "00000000000000000000000110", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
38 => OP_SR_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 132
39 => OP_MOVE_3 & "0110" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
40 => OP_MOVE_3 & "1000" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
41 => OP_IMM_3 & "1001" & "00000000000000000000000001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
42 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 124
43 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
44 => OP_JMP_3 & "0000" & "00000000000000000000011010", -- file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py line: 63
45 => OP_IMM_3 & "1000" & "00000000000000000000000001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
46 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
47 => OP_IMM_3 & "1000" & "00000000000000000000000001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
48 => OP_MOVE_3 & "0111" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
49 => OP_MOVE_3 & "1000" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
50 => OP_MOVE_3 & "1001" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
51 => OP_GE_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 139
52 => OP_IMM_3 & "1001" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
53 => OP_EQ_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 134
54 => OP_JMPF_3 & "1000" & "00000000000000000000111001", -- file: None line: None
55 => OP_JMP_3 & "0000" & "00000000000000000001000010", -- file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py line: 62
56 => OP_JMP_3 & "0000" & "00000000000000000000111001", -- file: None line: None
57 => OP_MOVE_3 & "1000" & "00000000000000000000000111", -- file: ./example_2_taylor_series.py line: 38
58 => OP_MOVE_3 & "1001" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
59 => OP_MUL_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 126
60 => OP_MOVE_3 & "0111" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
61 => OP_MOVE_3 & "1000" & "00000000000000000000000101", -- file: ./example_2_taylor_series.py line: 39
62 => OP_IMM_3 & "1001" & "00000000000000000000000001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
63 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 124
64 => OP_MOVE_3 & "0101" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
65 => OP_JMP_3 & "0000" & "00000000000000000000110001", -- file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py line: 63
66 => OP_MOVE_3 & "1000" & "00000000000000000000000010", -- file: ./example_2_taylor_series.py line: 35
67 => OP_MOVE_3 & "1001" & "00000000000000000000000100", -- file: ./example_2_taylor_series.py line: 41
68 => OP_MOVE_3 & "1010" & "00000000000000000000000110", -- file: ./example_2_taylor_series.py line: 37
69 => OP_MOVE_3 & "1011" & "00000000000000000000000111", -- file: ./example_2_taylor_series.py line: 38
70 => OP_DIV_3 & "1010" & "00000000000000000000001011", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 128
71 => OP_MUL_3 & "1001" & "00000000000000000000001010", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 126
72 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 124
73 => OP_MOVE_3 & "0010" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
74 => OP_IMM_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
75 => OP_MOVE_3 & "1001" & "00000000000000000000000100", -- file: ./example_2_taylor_series.py line: 41
76 => OP_SUB_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 141
77 => OP_MOVE_3 & "0100" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
78 => OP_MOVE_3 & "1000" & "00000000000000000000000011", -- file: ./example_2_taylor_series.py line: 36
79 => OP_IMM_3 & "1001" & "00000000000000000000000010", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 119
80 => OP_ADD_3 & "1000" & "00000000000000000000001001", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 124
81 => OP_MOVE_3 & "0011" & "00000000000000000000001000", -- file: /usr/local/lib/python2.6/dist-packages/streams/instruction.py line: 274
82 => OP_JMP_3 & "0000" & "00000000000000000000001110", -- file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py line: 63
83 => OP_MOVE_3 & "1000" & "00000000000000000000000010", -- file: ./example_2_taylor_series.py line: 35
84 => OP_WRITE_2_3 & "1000" & "00000000000000000000000000", -- file: /usr/local/lib/python2.6/dist-packages/streams/streams.py line: 371
85 => OP_JMP_3 & "0000" & "00000000000000000000000111", -- file: ./example_2_taylor_series.py line: 68
86 => OP_JMP_3 & "0000" & "00000000000000000001010110", -- file: None line: None
87 => OP_JMP_3 & "0000" & "00000000000000000000000000"); -- file: None line: None
  signal MOD_DIV_3      : std_logic;

begin

  process
  begin
    wait until rising_edge(CLK);
    TIMER_1us <= '0';
    TIMER_10us <= '0';
    TIMER_100us <= '0';
    TIMER_1ms <= '0';
    if TIMER_1us_COUNT = 0 then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '1';
       if TIMER_10us_COUNT = 0 then
         TIMER_10us_COUNT <= TIMER_10us_MAX;
         TIMER_10us <= '1';
         if TIMER_100us_COUNT = 0 then
           TIMER_100us_COUNT <= TIMER_100us_MAX;
           TIMER_100us <= '1';
           if TIMER_1ms_COUNT = 0 then
             TIMER_1ms_COUNT <= TIMER_1ms_MAX;
             TIMER_1ms <= '1';
           else
             TIMER_1ms_COUNT <= TIMER_1ms_COUNT - 1;
           end if;
         else
           TIMER_100us_COUNT <= TIMER_100us_COUNT - 1;
         end if;
       else
         TIMER_10us_COUNT <= TIMER_10us_COUNT - 1;
       end if;
    else
       TIMER_1us_COUNT <= TIMER_1us_COUNT - 1;
    end if;
    if RST = '1' then
       TIMER_1us_COUNT <= TIMER_1us_MAX;
       TIMER_1us <= '0';
       TIMER_10us_COUNT <= TIMER_10us_MAX;
       TIMER_10us <= '0';
       TIMER_100us_COUNT <= TIMER_100us_MAX;
       TIMER_100us <= '0';
       TIMER_1ms_COUNT <= TIMER_1ms_MAX;
       TIMER_1ms <= '0';
    end if;
  end process;

  --internal clock generator
  process
  begin
    while True loop
      CLK <= '0';
      wait for 5 ns;
      CLK <= '1';
      wait for 5 ns;
    end loop;
    wait;
  end process;

  --internal reset generator
  process
  begin
    RST <= '1';
    wait for 20 ns;
    RST <= '0';
    wait;
  end process;

  --file: ./example_2_taylor_series.py, line: 94
  --OutPort(2, 26)
  process
    file OUTFILE : text open write_mode is "resp_2.txt";
    variable OUTLINE : LINE;
    variable VALUE : integer;
  begin
    wait until rising_edge(CLK);
    STREAM_2_ACK <= '0';
    if STREAM_2_STB = '1' then
      STREAM_2_ACK <= '1';
    end if;    if STREAM_2_STB = '1' and STREAM_2_ACK = '1' then
      VALUE := to_integer(signed(STREAM_2));
      write(OUTLINE, VALUE);
      writeline(OUTFILE, OUTLINE);
    end if;  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 58
  --STREAM 1 Lookup()
  process
  begin
    wait until rising_edge(CLK);
    case STATE_1 is
      when UNARY_INPUT =>
        if STREAM_0_STB = '1' then
          STREAM_0_ACK <= '1';
          STREAM_1_STB <= '1';
          STREAM_1 <= LOOKUP_1(to_integer(unsigned(STREAM_0)));
          STATE_1 <= UNARY_OUTPUT;
        end if;
      when UNARY_OUTPUT =>
        STREAM_0_ACK <= '0';
        if STREAM_1_ACK = '1' then
           STREAM_1_STB <= '0';
           STATE_1 <= UNARY_INPUT;
        end if;
     end case;
     if RST = '1' then
       STREAM_1_STB <= '0';
       STREAM_0_ACK <= '0';
       STATE_1 <= UNARY_INPUT;
     end if;
  end process;

  --file: /usr/local/lib/python2.6/dist-packages/streams/__init__.py, line: 58
  --STREAM 0 Counter(0, 99, 1, 8)
  process
  begin
    wait until rising_edge(CLK);
    STREAM_0_STB <= '1';
    if STREAM_0_ACK = '1' then
      STREAM_0_STB <= '0';
      STREAM_0 <= STD_RESIZE(ADD(STREAM_0, "00000001"), 8);
      if STREAM_0 = "01100011" then
        STREAM_0 <= "00000000";
      end if;
    end if;
    if RST = '1' then
      STREAM_0_STB <= '0';
      STREAM_0 <= "00000000";
    end if;
  end process;

  -- process
  process
    variable INSTRUCTION : std_logic_vector(33 downto 0);
  begin
    wait until rising_edge(CLK);
    INSTRUCTION := INSTRUCTIONS_3(to_integer(PC_3));
    OPERATION_3 <= INSTRUCTION(33 downto 30);
    SRCA_3      <= INSTRUCTION(29 downto 26);
    SRCB_3      <= INSTRUCTION(3 downto 0);
    IMMEDIATE_3 <= INSTRUCTION(25 downto 0);
  end process;

  process
    variable REGA         : std_logic_vector(25 downto 0);
    variable REGB         : std_logic_vector(25 downto 0);
    variable DEST         : std_logic_vector(3 downto 0);
    variable RESULT       : std_logic_vector(25 downto 0);
    variable RESULT_DEL   : std_logic_vector(25 downto 0);
    variable REGISTERS_EN : std_logic;
    variable MODULO       : unsigned(25 downto 0);
    variable FLAG_EQ      : std_logic;
    variable FLAG_GT      : std_logic;
    variable FLAG_GE      : std_logic;
  begin
    wait until rising_edge(CLK);
    REGISTERS_EN := '0';
    case STATE_3 is
      when STALL =>
        PC_3 <= PC_3 + 1;
        STATE_3 <= EXECUTE;
      when EXECUTE =>
        REGA := REGISTERS_3(to_integer(unsigned(SRCA_3)));
        REGB := REGISTERS_3(to_integer(unsigned(SRCB_3)));
        DEST := SRCA_3;
        RESULT := REGA;
        PC_3 <= PC_3 + 1;

        --share comparator logic
        if REGA = REGB then
          FLAG_EQ := '1';
        else
          FLAG_EQ := '0';
        end if;

        if signed(REGA) > signed(REGB) then
          FLAG_GT := '1';
        else
          FLAG_GT := '0';
        end if;

        FLAG_GE := FLAG_GT or FLAG_EQ;

        --execute instructions
        case OPERATION_3 is
          when OP_MOVE_3 => 
            RESULT := REGB;
            REGISTERS_EN := '1';
          when OP_MUL_3  => 
            RESULT := STD_RESIZE( MUL(REGA, REGB), 26);
            REGISTERS_EN := '1';
          when OP_ADD_3  => 
            RESULT := STD_RESIZE( ADD(REGA, REGB), 26);
            REGISTERS_EN := '1';
          when OP_SUB_3  => 
            RESULT := STD_RESIZE( SUB(REGA, REGB), 26);
            REGISTERS_EN := '1';
          when OP_SR_3   => 
            RESULT := STD_RESIZE(  SR(REGA, REGB), 26);
            REGISTERS_EN := '1';
          when OP_EQ_3   => 
            RESULT := (others => FLAG_EQ);
            REGISTERS_EN := '1';
          when OP_GT_3   => 
            RESULT := (others => FLAG_GT);
            REGISTERS_EN := '1';
          when OP_GE_3   => 
            RESULT := (others => FLAG_GE);
            REGISTERS_EN := '1';
          when OP_IMM_3  => 
            RESULT := IMMEDIATE_3;
            REGISTERS_EN := '1';
          when OP_JMP_3 =>
            STATE_3 <= STALL;
            PC_3 <= resize(unsigned(IMMEDIATE_3), 7);
          when OP_JMPF_3 =>
            if RESULT_DEL = "00000000000000000000000000" then
              STATE_3 <= STALL;
              PC_3 <= resize(unsigned(IMMEDIATE_3), 7);
            end if;
          when OP_DIV_3 =>
            MOD_DIV_3 <= '1';
            A_3 <= std_logic_vector(abs(signed(REGA)));
            B_3 <= std_logic_vector(abs(signed(REGB)));
            SIGN_3 <= REGA(25) xor REGB(25);
            STATE_3 <= DIVIDE_0;
            PC_3 <= PC_3;
          when OP_WRITE_2_3 =>
            STATE_3 <= WRITE_STREAM_2;
            DEST := SRCA_3;
            PC_3 <= PC_3;
          when OP_READ_1_3 =>
            STATE_3 <= READ_STREAM_1;
            PC_3 <= PC_3;
          when others => null;
        end case;

        --write back results
        RESULT_DEL := RESULT;

      when DIVIDE_0 =>
        QUOTIENT_3 <= (others => '0');
        SHIFTER_3 <= (others => '0');
        SHIFTER_3(0) <= A_3(25);
        A_3 <= A_3(24 downto 0) & '0';
        COUNT_3 <= 25;
        STATE_3 <= DIVIDE_1;

      when DIVIDE_1 => --subtract
       --if SHIFTER - B is positive or zero
       if REMAINDER_3(25) = '0' then
         SHIFTER_3(25 downto 1) <= REMAINDER_3(24 downto 0);
       else
         SHIFTER_3(25 downto 1) <= SHIFTER_3(24 downto 0);
       end if;
       SHIFTER_3(0) <= A_3(25);
       A_3 <= A_3(24 downto 0) & '0';
       QUOTIENT_3 <= QUOTIENT_3(24 downto 0) & not(REMAINDER_3(25));
       if COUNT_3 = 0 then
         STATE_3 <= DIVIDE_2;
       else
         COUNT_3 <= COUNT_3 - 1;
       end if;

     when DIVIDE_2 =>
      REGISTERS_EN := '1';
      if MOD_DIV_3 = '1' then --if division
        if SIGN_3 = '1' then --if negative
          RESULT := std_logic_vector(-signed(QUOTIENT_3));
        else
          RESULT := QUOTIENT_3;
        end if;
      else
        MODULO := unsigned(SHIFTER_3)/2;
        if SIGN_3 = '1' then --if negative
          RESULT := std_logic_vector(0-MODULO);
        else
          RESULT := std_logic_vector(  MODULO);
        end if;
      end if;
      STATE_3 <= EXECUTE;
      PC_3 <= PC_3 + 1;
      when READ_STREAM_1 =>
        if STREAM_1_STB = '1' then
          STREAM_1_ACK <= '1';
          REGISTERS_EN := '1';
          RESULT := STD_RESIZE(STREAM_1, 26);
          STATE_3 <= ACK_STREAM_1;
        end if;
      when ACK_STREAM_1 =>
        STREAM_1_ACK <= '0';
        STATE_3 <= EXECUTE;
        PC_3 <= PC_3 + 1;
      when WRITE_STREAM_2 =>
        STREAM_2_STB <= '1';
        STREAM_2 <= STD_RESIZE(REGA, 26);
        if STREAM_2_ACK = '1' then
          STREAM_2_STB <= '0';
          STATE_3 <= EXECUTE;
          PC_3 <= PC_3 + 1;
        end if;
    end case;

    if RST = '1' then
      STATE_3 <= STALL;
      PC_3 <= "0000000";
      STREAM_1_ACK <= '0';
      STREAM_2_STB <= '0';
    end if;
    if REGISTERS_EN = '1' then
      REGISTERS_3(to_integer(unsigned(DEST))) <= RESULT;
    end if;
  end process;


  --subtractor
  REMAINDER_3 <= std_logic_vector(unsigned(SHIFTER_3) - resize(unsigned(B_3), 26));

end architecture RTL;

--+============================================================================+
--|                       **END OF AUTO GENERATED CODE**                       |
--+============================================================================+